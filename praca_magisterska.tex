\documentclass[printmode]{mgr}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fontenc}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{psfrag}
\usepackage{supertabular}
\usepackage{array}
\usepackage{hhline}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{enumitem}
\usepackage{afterpage}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color, colortbl}
\usepackage{hyphenat}
\usepackage[hidelinks]{hyperref}
\usepackage{ucs}
\usepackage{makecell}
\usepackage[edges]{forest}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}

\def\Size{4pt}
\tikzset{%
  folder/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
  },
  file/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
  },
}

\forestset{%
  declare autowrapped toks={pic me}{},
  pic dir tree/.style={%
    for tree={%
      folder,
      font=\ttfamily,
      grow'=0,
    },
    before typesetting nodes={%
      for tree={%
        edge label+/.option={pic me},
      },
    },
  },
  pic me set/.code n args=2{%
    \forestset{%
      #1/.style={%
        inner xsep=2\Size,
        pic me={pic {#2}},
      }
    }
  },
  pic me set={directory}{folder},
  pic me set={file}{file},
}

\makeatletter
\pgfplotsset{
    /pgfplots/flexible xticklabels from table/.code n args={3}{%
        \pgfplotstableread[#3]{#1}\coordinate@table
        \pgfplotstablegetcolumnbyindex{#2}\of{\coordinate@table}\to\pgfplots@xticklabels
        \let\pgfplots@xticklabel=\pgfplots@user@ticklabel@list@x
    }
}
\makeatother
\raggedbottom

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}

\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, \$scope},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{mymauve}\ttfamily,
  sensitive=true
}

\lstdefinelanguage{Slim}{
  keywords={ul, div, a, href, i, li},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{mymauve}\ttfamily,
  sensitive=true,
}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  frame=single,  
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,
  inputencoding=utf8x, 
  extendedchars=\true,
  literate={ą}{{\k{a}}}1
  {Ą}{{\k{A}}}1
  {ę}{{\k{e}}}1
  {Ę}{{\k{E}}}1
  {ó}{{\'o}}1
  {Ó}{{\'O}}1
  {ś}{{\'s}}1
  {Ś}{{\'S}}1
  {ł}{{\l{}}}1
  {Ł}{{\L{}}}1
  {ż}{{\.z}}1
  {Ż}{{\.Z}}1
  {ź}{{\'z}}1
  {Ź}{{\'Z}}1
  {ć}{{\'c}}1
  {Ć}{{\'C}}1
  {ń}{{\'n}}1
  {Ń}{{\'N}}1
}

\newcommand\blankpage{%
  \null
  \thispagestyle{empty}%
  \addtocounter{page}{-1}%
  \newpage}

\renewcommand\bibname{Literatura}
\renewcommand{\lstlistingname}{Fragment kodu}

\date{2017}

\title{Analiza porównawcza frameworków internetowych w~języku Ruby w~zastosowaniach GISowych}
\engtitle{Comparative analysis of Ruby's web frameworks for Geographic Information Systems}
\author{Mikołaj Grygiel}
\supervisor{dr inż. Roman Ptak}

\field{Informatyka (INF)}
\specialisation{ Inżynieria systemów informatycznych (INS)}

\begin{document}
\bibliographystyle{plabbrv}

\maketitle

\tableofcontents

\chapter{Wprowadzenie}
\section{Cel pracy}
Język Ruby zajmuję 12 miejsce w~rankingu popularności języków programowania \emph{Tiobe}\footnote{Dane z~marca 2017 roku dostępne na stronie https://www.tiobe.com/tiobe-index/}. Dużą popularnością wśród frameworków internetowych cieszy się Ruby on Rails, w~rankingu \emph{Hotframeworks}\footnote{Ranking https://hotframeworks.com bierzę pod uwagę liczba repozytoriów kodu na platformie Github i~ilość tematów na forum Stackoverflow dotyczących danego frameworku. Dane z~dnia 26.03.2017 r.} zajmuję 3 miejsce wśród wszystkich frameworków. Ruby on Rails jest bez wątpienia najpopularniejszym frameworkiem w~języku Ruby, kolejne dwa frameworki w~języku Ruby to Sinatra i~Hanami, zajmują w~wcześniej przytoczonym rankingu odpowiednio miejsca 25. i~73. Jednak w~języku Ruby istnieje kilkanaście frameworków przeznaczonych do budowania aplikacji internetowych.

Celem niniejszej pracy jest poznanie wybranych frameworków w~języku Ruby, ich porównanie w~konkretnym zastosowaniu jakim są systemy informacji geograficznej oraz odpowiedź na pytanie jaki framework najlepiej wybrać do tworzenia systemu GIS.

\section{Zakres i koncepcja pracy}
"Framework" można zdefiniować jako szkielet służący do budowania aplikacji, czyli zbiór gotowych rozwiązań powtarzających się problemów i~wzór do budowania nowych funkcjonalności.\cite{framework}

W niniejszej pracy zostaną omówione wybrane frameworki w języku Ruby w świetle ich użyteczności przy budowie systemu informacji geograficznej. Frameworki zostaną porównane na podstawie informacji zawartych w dostępnej dokumentacji narzędzia oraz zaimplementowanej przykładowej aplikacji, za pomocą każdego z wybranych narzędzi, spełniającej wymagania systemu GIS.


\chapter{Podstawy teorytyczne}

\section{Charakterystyka Systemów Informacji Geograficznej}
System Informacji Geograficznej skrótowo nazywany GIS (ang. Geographic Information System) można zdefiniować na wiele sposobów. Michael Schmandt w~swoim opracowaniu\cite{gis_introduction} podaje następujące definicje:

\paragraph*{Definicja 1.}
GIS jest to system komputerowym składającym się z~sprzętu i~oprogramowania oraz ludzie, którzy wspomagają zbieranie, zarządzanie, analizowanie i~wyświetlanie danych przestrzennych. Stosując tą definicje możemy podzielić system GIS na 4 moduły:

  \begin{itemize}
    \item moduł wprowadzania danych - zawiera narzędzia pozwalające na wprowadzania i~przechowywanie danych przestrzennych.
    \item moduł zarządzania danymi - ta część umożliwia edytowanie oraz przeglądanie zgromadzonych zbiorów danych
    \item moduł analizowania danych - podsystem, który odpowiada za analizowanie danych geograficznych i~wyciągania z~nich informacji
    \item moduł prezentowania danych - pozwala na tworzenie map, modeli, statystyk ilustrujących zgromadzone dane
  \end{itemize}

\paragraph*{Definicja 2.}
System informacji geograficznej to system komputerowy, który pozwala na przechowywanie danych powiązanych ze sobą geograficznie.

\paragraph*{Definicja 3.}
GIS to narzędzie do wyszukiwania wzorców geograficznych(przestrzennych) w~zbiorach danych.

Pierwsza definicja jest najbardziej szeroka i~zawiera w~sobie dwie następne - definicja druga to dwa pierwsze moduły z~\textbf{Definicja 1.}, a~definicja trzecia to moduł analizowania danych.

W podobny sposób do definicji nr 1 GIS jest zdefiniowany w~\emph{Principles of Geographic Information Systems}\cite{principles_gis} jako zbiór narzędzi pozwalających operować na danych reprezentujących zjawiska geograficzne. Zbiór ten dzieli się na 4 grupy ze względu na funkcje:
  \begin{itemize}
    \item zbieranie i~przygotowywanie danych
    \item zarządzanie i~przechowywanie danych
    \item analiza danych
    \item prezentowanie danych
  \end{itemize}

W poniższej pracy przyjmuje się pierwszą definicje Systemu Informacji Geograficznego - GIS to system informatyczny służący do wprowadzania, przechowywania, zarządzania, analizowania i~prezentacji danych przestrzennych.

\section{Charakterystyka języka Ruby}
Język Ruby został wydany w~1995 roku. Twórca Rubiego, Yukihiro “Matz” Matsumoto, inspirował się takimi językami programowani jak Perl, Smalltalk, Eiffel, Ada i~Lisp by stworzyć jego zdaniem język, który zbalansuje programowanie funkcjonalne z~programowanie imperatywnym\cite{doc_ruby}. Składnia Rubiego ma przypominać język naturalny, autor języka opisuje go jako: \emph{Ruby jest prosty z~wyglądu, ale bardzo skomplikowany w~środku, tak jak ciało ludzkie.}\footnote{wypowiedź w~liście ruby-talk 12.05.2000 r., źródło: http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/2773}

Ruby jest językiem ściśle obiektowym, wszystko postrzegane jest jako obiekt. Każda funkcja jest metodą, ponieważ musi być przyłączona do jakiegoś obiektu. Ruby posiada celowo tylko jednokrotne dziedziczenie, ale pozwala na dołączanie wielu modułów, które są zbiorami metod do klasy. Ruby jest bardzo elastycznym językiem, pozwala na usunięcie lub przedefiniowanie dowolnej swojej części. Mimo silnie obiektowej natury, dostępne są również elementy programowania funkcyjnego takie jak funkcje anonimowe lub domknięcia.

Szerszą popularność Ruby zyskał w~2006r., 11 lat po publikacji. Swoją popularność zawdzięcza głównie frameworkowi Ruby on Rails. w~rankingu popularności języków programowania Tiobe znajduje się aktualnie na 12 miejscu\footnote{dane z~dnia 08.04.2016 r. https://www.tiobe.com/tiobe-index/}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/ruby_tiobe}
  \caption{Histora popularności języka Ruby według rankingu Tiobe}
  \label{fig:ruby_tiobe}
\end{figure}

\chapter{Istniejące systemy GIS w~języku Ruby}

\section{OpenStreetMap}

  OpenStreetMap jest internetowym systemem informacji geograficznej z~otwartym kodem źródłowym. System zbudowany z~wykorzystaniem bazy danych PostgreSQL, frameworku Ruby on Rails oraz biblioteki javascriptowej Leaflet służącej do tworzenia interaktywnych widoków z~mapami. Dostęp do danych jest otwarty, dane mogą być edytowane przez dowolnego użytkownika, dlatego mogą być niezgodne z~rzeczywistością. OpenStreetMap definiuje 4 typy obiektów przestrzennych\cite{doc_osm}:
  \begin{itemize}
    \item Węzeł (ang. node) - pojedynczy punkt geoprzestrzenny reprezentowany przez długość i~szerokość geograficzną.
    \item Linia (ang. way) - jest to uporządkowany zbiór punktów, które mogą reprezentować funkcje liniowe(wektory) lub obszary.
    \item Relacja (ang. relation) - składa się z~uporządkowanej listy węzłów, linii i~innych relacji.
    \item Tag (ang. tag) - to jednostka informacji dołączona do obiektu jednego z~powyżej opisanych typów. Tag składa się z~klucza oraz wartości. 
  \end{itemize}

  OpenStreetMap można wykorzystać przez utworzenie komponentu HTML z~wybraną mapą, gotowego do zamieszczenia na dowolnej stronie internetowej lub przez pobranie danych z~wybranej mapy. Skompresowane aktualne dane dla całej planety z~pojedynczego dnia zajmują prawie 40GB. Można pobierać również dane historyczne.

\section{MangoMap}

  MangoMap jest komercyjnym narzędziem do tworzenia map dostępnych przez internet z~własnych danych geoprzestrzennych. Ceny za korzystanie z~serwisu wynoszą 49-399\$ miesięcznie w~zależności od liczby map i~udostępnianego miejsca na serwerze do przechowywania danych. System zbudowany jest w~oparciu o~framework Ruby on Rails. Mapy tworzy się przy użyciu interfejsu graficznego. Stworzone mapy mogą być udostępnione na serwerze MangoMap przez unikalny link lub zamieszczone na zewnętrznej stronie WWW przez komponent HTML\cite{doc_mango}.

\chapter{Frameworki internetowe w~języku Ruby}

W języku Ruby istnieje kilkanaście wspieranych frameworków internetowych. Wybór wykorzystanych frameworków w~niniejszej pracy dokonano w~następujący sposób:
  \begin{enumerate}
    \item Podzielono frameworki według daty opublikowania pierwszej wersji na 3 grupy:
    \begin{enumerate}
      \item opublikowane w~latach 2004 - 2011 - frameworki o~ugruntowanej pozycji
      \item opublikowane w~latach 2012 - 2015 - stosunkowo nowe frameworki
      \item opublikowane w~latach 2016 - 2017 - najnowsze frameworki
    \end{enumerate}
    \item z~każdej grupy wybrano framework z~największą ilością pobrań.
  \end{enumerate}
Ta metoda ma na celu wyłonienie najpopularniejszych frameworków, które powstały w~różnych etapach języka Ruby, jednocześnie każdy z~nich współpracuje z~najnowszą wersją języka. w~ten sposób wybrano \emph{Ruby on Rails, Trailblazer i~Hanami.}


\begin{table}[H]
  \caption{ Frameworki internetowe w~języku Ruby \protect\footnotemark}
  \centering
  \begin{tabularx}{1\linewidth}{|X|X|X|X|} \hline
    Nazwa & Data opublikowania \newline pierwszej wersji & Data opublikowania \newline  najnowszej wersji & Ilość pobrań \\ \hline
    \rowcolor{lightgray}
    Ruby on Rails & 25.10.2004 r. & 20.03.2017 r. & 91 898 706 \\ \hline
    Hobo & 29.04.2007 r. & 07.05.2016 r. & 211 042 \\ \hline
    Sinatra & 04.10.2007 r. & 19.03.2017 r. & 45 207 501 \\ \hline
    Padrino & 16.11.2009 r. & 23.03.2017 r. & 556 481 \\ \hline
    Cuba & 25.04.2010 r. & 01.07.2016 r. & 124 371 \\ \hline
    Strelka & 24.08.2011 r. & 19.01.2017 r. & 57 007 \\ \hline
    Pakyow & 20.09.2011 r. & 15.07.2016 r. & 18 222 \\ \Xhline{4\arrayrulewidth}
    Scorched & 03.03.2013 r. & 12.10.2016 r. & 26 929 \\ \hline
    Trailblazer & 26.07.2013 r. & 23.01.2017 r. & 96 217 \\ \hline
    \rowcolor{lightgray}
    Roda & 20.07.2014 r. & 15.03.2017 r. & 105 103 \\ \hline
    Vanilla & 09.05.2015 r. & 05.07.2016 r. & 80 125 \\ \Xhline{4\arrayrulewidth}
    \rowcolor{lightgray}
    Hanami & 20.01.2016 r. & 06.04.2017 r. & 28 885 \\ \hline
    Dry-web & 21.04.2016 r. & 02.02.2017 r. & 7 190 \\ \hline
  \end{tabularx}
\end{table}
\footnotetext{Zestawienia przygotowano na podstawie danych z~https://rubygems.org/ oraz https://www.ruby-toolbox.com. Pominięto frameworki, których ostatnia wersja ukazała się ponad rok temu. Aktualne na dzień 08.04.2017 r.}

\section{Ruby on Rails}

Pierwsza stabilna wersja (1.0.0) frameworku Ruby on Rails ukazała się pod koniec 2005 roku, aktualna wersja (5.0.2) została opublikowana 02.03.2017 r. Aplikacja zbudowana z~wykorzystanie RoR jest oparta o~wzorzec projektowy Model-Widok-Kontroler\cite{rails_agile} (ang. Model-View-Controller). Aplikacja oparta na tym wzorcu jest podzielona na 3 części:
\begin{itemize}
  \item Modele (ang. model) - reprezentują logikę biznesową. w~tej warstwie znajdują się wszelkie obiekty, które służą do wykonywania operacji związanych z~implementacją funkcjonalności aplikacji.
  \item Widoki (ang. view) - służą do prezentowania danych. 
  \item Kontrolery (ang. controller) - obsługują zapytania użytkownika. Nie zawierają w~sobie żadnej logiki biznesowej.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/rails_mvc}
  \caption{Architektura aplikacji w~Ruby on Rails, źródło: http://blog.ifuturz.com/ruby-on-rails/ruby-on-rails-mvc-learn-with-fun.html}
  \label{fig:rails_mvc}
\end{figure}
\newpage
Dwie główne zasady frameworku\cite{doc_rails}:

\begin{itemize}
  \item Nie powtarzaj się (ang. Don't Repeat Yourself) - każda informacja powinna mieć pojedynczą, jednoznaczną i~autorytatywną reprezentacje w~kodzie źródłowym systemu. Ułatwia to utrzymywanie kodu.
  \item Konwencja ponad konfiguracje (ang. Convention Over Configuration) - RoR posiada ustalone zasady postępowania w~różnych przypadkach. Aplikacja domyślnie zachowuje się według tych zasad, nie wymagając dodatkowej konfiguracji. Pozwala to zredukować ilość kodu źródłowego.
\end{itemize}


\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [app
        [controllers]
        [models]
        [views]
      ]
    ]
  \end{forest}
  \caption{Podstawowa struktura projektu Ruby on Rails}
  \label{fig:rails_structure}
\end{figure}

\section{Roda}

Twórcy frameworku Roda jest przy tworzeniu narzędzia podstawili sobie 4 cele\cite{doc_roda}:
  \begin{itemize}
    \item Prostota (ang. simplicity) - framework ma być prosty zarówno wewenątrz(w implementacji), jak i na zewnątrz (dla użytkowników).
    \item Niezawodność (ang. reliability) - Roda wspiera i promuje projektowanie aplikacji z niemutowalnym stanem. Aplikacje zbudowane za pomocą Rody, są zaprojektowane tak. Roda ogranicza zmienne, stałe i metody przypisane do instancji obiektów aby uniknąć konfliktów z kodem zaimplementowanym przez użytkownika.
    \item Rozszerzalność (ang. extensibility) - framework zbudowany jest całkowicie w oparciu o wtyczki, aby ułatwić dodawanie funkcjonalności do frameworka. Każda część Rody może być zastąpiona własną implementacją przez użytkownika.
    \item Wydajność (ang. performance) - Roda posiada mały koszt obsługi zapytań, drzewo trasowania i inteligentną obsługę pamięci podręcznej co sprawia, że Roda jest szybsza od innych popularnych frameworków języka Ruby.
  \end{itemize}
Roda opiera się o drzewo trasowania, punkty dostępu aplikacji zdefiniowane są w strukturze drzewa. Przykład drzewa trasowań znajduje się we fragmencie kodu \ref{lst:routing_tree}.

\begin{lstlisting}[language=Ruby, caption={Proste drzewo trasowań}, label=lst:routing_tree]
r.on "a" do           # /a gałęź
  r.on "b" do         # /a/b gałęź
    r.is "c" do       # /a/b/c zapytanie
      r.get do end    # GET  /a/b/c zapytanie
      r.post do end   # POST /a/b/c zapytanie
    end
    r.get "d" do end  # GET  /a/b/d zapytanie
    r.post "e" do end # POST /a/b/e zapytanie
  end
end
\end{lstlisting}

W przeciwieństwie do Ruby on Rails, Roda nie posiada warstwy kontrolerów i osobnego modułu obsługującego trasowanie, w Rodzie przy definicji danego punktu końcowego znajduje się od razu kod obsługujący otrzymane zapytanie.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/roda_architecture}
  \caption{Architektura aplikacji w frameworku Roda}
  \label{fig:roda_architecture}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [models]
      [routes]
      [views]
    ]
  \end{forest}   
  \caption{Struktura projektu Roda}
  \label{fig:roda_proj_structure}
\end{figure}

\section{Hanami}

Hanami jest lekkim frameworkiem internetowym opartym o~architekturę MVC, zbudowanym z~wielu mikro-bibliotek. w~przeciwieństwie do Ruby on Rails, Hanami nie stawia konwencji ponad konfiguracje, wszystkie informacje powinny być zawarte w~napisanym przez programistę kodzie, którego zrozumienie nie wymaga znajomości konwencji frameworka. Architekura projektu jest głównie inspirowana przez te dwa podejścia:

\begin{itemize}
  \item Czysta architektura (ang. clean architecture) - schemat tej architektury składa się z~kolejnych zawierających się w~sobie kół. Każde wewnętrzne koło nie ma żadnych zależności w~zewnętrznym kole, czyli w~obiektach należących do wewnętrznego koła, nie ma odwołań do obiektów z~zewnętrznych kół\cite{clean_architecture}. To podstawowa zasada tego podejścia. 

  \begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{pictures/clean_architecture}
    \caption{Schemat czystej architektury\cite{clean_architecture}}
    \label{fig:clean_architecture}
  \end{figure}

  Na schemacie \ref{fig:clean_architecture} można wyróżnić 4 byty:

  \begin{itemize}
    \item Encje (ang. entities) - zawierają ogólne reguły biznesowe systemu. Mogą być reprezentowane przez obiekty z~metodami, struktury danych lub pojedyncze funkcje.
    \item Przypadki użycia (ang. use cases) - ta warstwa skupia w~sobie wszystkie możliwe przypadki użycia systemu przez użytkownika. Znajduje się tu cała logika biznesowa zarządzania encjami. Zmiana w~tej warstwie nie powinna wpływać na encje, interfejs użytkownika lub bazę danych.
    \item Adaptery interfejsów (ang. interface adapters) - na tym poziomie dane są konwertowane z~formatu najbardziej dogodnego dla przypadków użycia i~encji do formatu przyjmowanego przez zewnętrzne narzędzia takie jak baza danych lub przeglądarka internetowa. 
    \item Frameworki oraz narzędzia (ang. frameworks and drivers) - w~tej warstwie znajdują się zewnętrzne narzędzia takie jak inne frameworki, baza danych lub przeglądarka internetowa.
  \end{itemize}

  \item Najpierw monolit (ang. monolith first) - według tej zasady budowę systemu zaczyna się od monolitycznej aplikacji. Jednak budowa aplikacji od samego początku powinna być jak najbardziej modularna aby można było ją później rozbić na wiele mniejszych aplikacji.

  Zgodnie z~zasadą \emph{czystej architektury} w~utworzonym projekcie systemu z~użyciem Hanami oddzielona jest warstwa logiki biznesowej znajdująca się w~folderze \emph{lib\\} projektu od mechanizmu komunikacji z~innymi serwisami zawartego w~folderze \emph{apps\\}.

  Hanami posiada kontener aplikacji, który pozwala nam utworzyć wiele aplikacji w~ramach jednego projektu, które korzystają z~tego samego zbioru encji i~przypadków użycia, a~następnie uruchomić je w~jednym procesie Rubiego.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [apps
        [web
          [controllers]
          [templates]
          [views]
        ]
      ]
      [lib
        [main
          [entities]
          [repositories]
        ]
      ]
    ]
  \end{forest}
  \caption{Podstawowa struktura projektu Hanami}
  \label{fig:hanami_structure}
\end{figure}

\chapter{Narzędzia dostępne do przetwarzania danych geograficznych w~języku Ruby}
\section{Przechowywanie danych}
Omawiane frameworki domyślnie wykorzystują relacyjną bazę danych do przechowywania informacji. Najpopularniejsze bazy danych to PostgreSQL, MySQL, SQLite.
\subsection{PostgreSQL}
PostgreSQL posiada kilka wbudowanych typów przestrzennych\cite{doc_postgresql}: 
\begin{itemize}
  \item Point - reprezentuje punkt na mapie, to podstawowy typ, który służy do budowania pozostałych typów przestrzennych. Dane zapisane są jako para współrzędnych w postaci tekstowej \textit{( x, y )}, gdzie x i y to liczby zmienno przecinkowe.
  \item Line - prosta w znaczeniu geometrycznym, mogą być reprezentowane przez równanie liniowe \textit{Ax + By + C = 0}, wtedy w bazie danych zapisane są współczynniki \textit{A, B, C}. Innym sposobem reprezentacji tego typu są dwa punkty, przez które przechodzi prosta \textit{[ ( x1 , y1 ) , ( x2 , y2 ) ]
  }.
  \item Line Segment - w znaczeniu geometrycznym to odcinek, reprezentowany przez dwa punkty, początek i koniec odcinka \textit{[ ( x1 , y1 ) , ( x2 , y2 ) ]}.
  \item Box - to czworokąty zapisane jako dwa przeciwległe wierzchołki \textit{( ( x1 , y1 ) , ( x2 , y2 ) )}.
  \item Path - lista połączonych ze sobą punktów, ścieżka. Ścieżka może być otwarta, jeśli pierwszy i ostatni punkt nie są ze sobą połączone, lub zamknięta, jeśli pierwszy i ostatni punkt są ze sobą połączone. Nawiasy kwadratowe reprezentują otwartę ścieżkę \textit{[ ( x1 , y1 ) , ... , ( xn , yn ) ]}, zamnkięta ścieżka jest przedstawiona za pomocą okrągłych nawiasów \textit{( ( x1 , y1 ) , ... , ( xn , yn ) )}.
  \item Polygon - to wielokąt zapisany za pomocą listy punktów, reprezentujących kolejne wierzchołki wielokątu \textit{( ( x1 , y1 ) , ... , ( xn , yn ) )}.
  \item Circle - okrąg zapisany przy pomocy środka i promienia \textit{< ( x , y ) , r >}.
\end{itemize}
PostgreSQL dostarcza niewiele funkcji do wyszukiwania danych. Sprawdzenie zależności między dwoma punktami takich jak np. przecięcie dwóch obiektów lub zawieranie się jednego punktu w drugim nie jest dostępne dla typów \textit{Path} i \textit{Polygon}. 
\subsection{PostGIS}
PostGIS jest biblioteką rozszerzającą możliwości PostgreSQL w zakresie przetwarzania danych przestrzennych. Biblioteka jest wspierana przez fundacje \textit{Open Source Geospatial}\cite{doc_postgis}. Dane są zapisane w formie binarnej jako współrzędne geograficzne lub geometryczne w zależności od wyboru. Postgis zapewnia wsparcie typów zdefiniowanych przez \textit{Open Geospatial Consortium}:
\begin{itemize}
  \item POINT - pojedynczy punkt na mapie.
  \item LINESTRING - zbiór połączonych ze sobą punktów reprezentujący ścieżkę.
  \item POLYGON - zbiór połączonych ze sobą punktów reprezentujący wierzchołki wielokątu.
\end{itemize}
\textit{Open Geospatial Consortium} definiuje również kolekcje obiektów powyższych typów:
\begin{itemize}
  \item MULTIPOINT - kolekcja punktów.
  \item MULTILINESTRING - kolekcja linii.
  \item MULTIPOLYGON - kolekcja wielokątów.
  \item GEOMETRYCOLLECTION - kolekcja dowolnych obiektów geometrycznych.
\end{itemize}
Dla wszystkich typów dostępny jest taki sam zestaw funkcji, które np. sprawdzają zależności między dwoma obiektami, co jest pomocne przy wyszukiwaniu obiektów.

\subsection{MySQL Spatial}
MySQL Spatial jest rozszerzeniem dla bazy MySQL, które dostarcza wsparcie dla danych przestrzennych. Rozszerzenie dostarcza typy danych zdefiniowane przez grupę \textit{Open Geospatial Consortium}\cite{doc_mysql}. Zbiór funkcjonalności pokrywa się z funkcjonalnościami rozszerzenia Postgis.
\subsection{SpatiaLite}
SpatiaLite jest rozszerzeniem dla bazy danych SQLite, które zawiera wsparcie dla typów przestrzennych zdefiniowanych przez grupę \textit{Open Geospatial Consortium}\cite{doc_spatialite}: \textit{Point, Line, Multiline, Polygon, Multipolygon}. Cała baza danych zapisana jest w pojedynczym pliku. Biblioteka udostępniona jest na zasadzie otwartego źródła.

\section{Obiektowe przetwarzanie danych}
\subsection{RGeo}
RGeo wspiera typy danych zdefiniowane przez \textit{Open Geospatial Consortium}, takie jak punkt, linia i wielokąt. Dane są reprezentowane w formie obiektowej. Biblioteka pozwala na podstawowe operacje analizowania danych przestrzennych, takie jak szukanie punktów przecięcia i obliczenia pola powierzchni. Biblioteka operuje na reprezentacji geograficznej i gemoetrycznej danych i pozwala konwertować dane pomiędzy dostępnymi reprezentacjami. RGeo udostępnia udostępnia jedynie interfejs w języku Ruby dla programistów, a do obsługi danych geograficznej korzysta z bibliotek GEOS i proj.4, te biblioteki są napisane w języku C++.

\subsection{GeoRuby}
GeoRuby jest biblioteką całkowicie napisaną za pomocą języka Ruby do przetwarzania danych przestrzennych. Biblioteka ściśle podąża za modelem danych definiowanych przez \textit{Open Geospatial Consortium}, dlatego dobrze łączy się z takimi bazami danych jak Postgis, Mysql Spatial, SpatiaLite i innymi, które również wspierają typu opracowane przez OGC\cite{doc_georuby}.

\section{Prezentowanie danych}
\label{sec:maps-tools}
\subsection{Leaflet}
Leaflet jest biblioteką napisaną w języku Javascript, która pozwala dodać interaktywną mapę do widoku aplikacji internetowej. Biblioteka nie dostarcza graficznej reprezentacji mapy, ale zapewnia obsługę mapy z zewnętrznego serwisu np. OpenStreetMap. Do mapy można dodawać interaktywne obiekty. Biblioteka dostępna jest na zasadzie otwartego źródła.\cite{doc_leaflet}

\subsection{GoogleMaps JavaScript API}
GoogleMaps JavaScript API pozwala dołączyć mapę z serwisu Google Maps. Mapa jest interaktywna i pozwala wyświetlać obiekty dodane przez programistę. W darmowejwersji GoogleMaps API pozwala wczytać mapę 25 000 razy w ciągu dnia.\cite{doc_google}


\chapter{Badania}

\section{Plan badań}

Na podstawie dostępnej dokumentacji oraz zaimplementowanych aplikacji w każdym z badanych narzędzi, frameworki zostaną porównane w następującyh aspektach:
\begin{itemize}
  \item dostępne funkcjonalności
  \item struktura utworzonego projektu
  \item wydajność zaimplementowanej aplikacji
\end{itemize}


\subsection{Aplikacja zaimplementowana na potrzeby badań}

W~celu wykonania analizy porównanwczej w~każdym z~wybranych frameworków została zaimplementowana aplikacja internetowa operująca na danych geograficznych posiadająca takie same funkcjonalności. Aplikacje zostały zrealizowane zgodnie z architekturą i konwencją wykorzystywanymi w danym frameworku zawartych w dokumentacji narzędzia. W projektach wykorzystano jedynie biblioteki niezbędnę do zrealizowania wymaganych funkcjonalności. Nie używano bibliotek modyfikujących architekturę aplikacji lub funkcjonalności frameworka.
Aplikacja ma za zadanie wykonywać 4 podstawowe operacje na danych geograficznych:
\begin{itemize}
  \item tworzenie
  \item odczytywanie
  \item aktualizowanie
  \item usuwanie
\end{itemize}

Wszystkie funkcjonalności wykonanej aplikacji zostały zaprezentowane na rysunku \ref{fig:use_cases}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/use_cases}
  \caption{Diagram przypadków użycia aplikacji}
  \label{fig:use_cases}
\end{figure}

Aby przeprowadzić badania w realistycznych warunkach aplikacja korzysta z gotowych zbiorów danych:
\begin{itemize}
  \item punkty - pochodzące ze zbioru "Państwowy rejestr nazw geograficznych - miejscowości", zbiór zawiera 256796 obiektów, dostępny jest pod adresem http://www.codgik.gov.pl/index.php/darmowe-dane/prng.html
  \item linie - dane uzyskano z serwisu http://download.geofabrik.de/europe/poland.html pozwalającego pobrać drogi z terenu Polski z bazy danych OpenStreetMap. Zbiór obejmuje 2519660 obiektów
  \item wielokąty - obiekty pobrano z Państwowego Rejestru Granic dostępnego pod adresem http://gis-support.pl/baza-wiedzy/dane-do-pobrania/, zbiór liczy 59978 obiektów
\end{itemize}

Każda wersja aplikacji posiada taką samą bazę danych, której schemat znajduje się na rysunku \ref{fig:erd}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/erd}
  \caption{Schemat ERD bazy danych}
  \label{fig:erd}
\end{figure}

Do prezentacji danych na mapie wykorzystano bibliotekę LefletJS, ponieważ jest darmowa i ma otwarte źródła. Mapa pochodzi z serwisu OpenStreetMap. Widok gotowej aplikacji znajduje się na rysunku \ref{fig:app}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/app}
  \caption{Widok gotowej aplikacji}
  \label{fig:app}
\end{figure}

\subsection{Narzędzia wykorzystane podczas badań}
selenium, capybara, jmeter, ruby benchmark

\subsection{Środowisko badawcze}

\section{Porównianie funkcjonalności wybranych frameworków}

\subsection{Przechowywanie danych}

 Ruby on Rails posiada największe wsparcie w przechowywaniu danych geograficznych z rozpatrywanych narzędzi. Biblioteka ActiveRecord domyślne wykorzystywana w Ruby on Rails do mapowania obiektowo-relacyjnego posiada adaptery dla następujących baz danych: PostgreSQL z dodatkiem PostGIS, MysqlSpatial, SpatiaLite. Za pomocą adapterów, w migracjach można używać typów kolumn z przestrzennych baz danych. Przy komunikacji typy przestrzenne z bazy danych mapowane są na typy zaimplemetowane w bibliotece RGeo. Konfiguracja nie wymaga wiele pracy, wystarczy dodać odpowiednią bibliotekę do projektu i w konfiguracji bazy danych ustawić odpowiedni adapter. Od tego momentu można w migracjach przy definiowaniu kolumn używać wszystkich typów przestrzennych dostarczanych przez wybraną bazę danych. Dane przestrzenne podczas wykonywanych akcji między aplikacją, a bazą danych są automatycznie mapowane.

 Hanami w migracjach pozwala uzywać kodu napisanego w języku sql do np. definiowania typów lub włączania dodatków w bazie danych, dlatego bez problemów można stworzyć i wersjonować bazę danych z typami przestrzennymi. Jednak framework, podobnie jak Ruby on Rails, posiada mechanizm automatycznego mapowania typów bazy danych do typów obiektów, który nie pozwala na definiowanie własnych typów lub własnych reguł mapowania. To ograniczenie powoduje otrzymanie wyjątku przy próbie uruchomienia aplikacj zawierającej nieznany typ. Framework wspiera jedynie typy przestrzenne zdefiniowane w bazie danych Postgresql, które są zapisywane postaci tekstowej zawierającej współrzędne. Możliwe jest zapisanie wszystkich 3 podstawowych typów przestrzennych: punktu, lini, wielokąta. Postgresql dostarcza podstawowe operacje wyszukiwania danych przestrzennych tylko dla punktów, dlatego zastosowanie Postgresql bez dodatku Postgis mocno ogranicza możliwości budowanej aplikacji. Dodanie obsługi typów geometrycznych dostarczonych przez dodatek Postgis nie wymaga dużej ilości kodu, wymagana jest dobra znajomość języka Ruby i mechanizmu przedefiniowania istniejących już klas tzw. "monkey patching". Najłatwiejsze rozwiązanie pozwalające używać typów geometrycznych z biblioteki Postgis znajduje się na listingu \ref{lst:postgis_patching}. Przy takim rozwiązaniu wartości z kolumny geometrycznnej mapowane są na typ String z wartością binarną.

 \newpage

\begin{lstlisting}[language=Ruby, caption={Obsługa typów geometrycznych z biblioteki Postgis przez Hanami}, label=lst:postgis_patching]
require 'rom/sql/extensions/postgres/inferrer'
require 'rom/sql/extensions/postgres/types'

ROM::SQL::Schema::PostgresInferrer.class_eval do
  alias map_db_type_original map_db_type

  def map_db_type(db_type)
    # najpierw następuje próba użycia oryginalnej metody mapowania typów
    # jeśli zakończy się ona nie powodzeniem, to następuje sprawdzenie 
    # czy typ kolumny z bazy danych rozpoczyna się od słowa 'geometry'
    # wtedy dane są rzutowane do typu ROM::Types::String
    map_db_type_original(db_type) || (db_type.start_with?('geometry') ? ROM::Types::String : nil)
  end
end
\end{lstlisting}

\subsection{Przetwarzanie danych}

 Do obiektowego przetwarzania danych dostępne są dwie biblioteki Rgeo i GeoRuby. Ruby on Rails, dzięki wspomnianym wcześniej adapterom dużo wygodniej jest korzystać z Rgeo dzięki automatycznemu mapowaniu danych relacyjnych na obiekty.
 Framework Hanami w żaden sposób nie rozszerza możliwości bibliotek Rgeo i GeoRuby. W zaimplementowanej metodzie mapującej wartości przestrzenne na typ obiektowy otrzymujemy wartość binarną, którą dalej można zamienić na typ z biblioteki Rgeo, co zaprezentowano na listingu \ref{lst:coordinates_helper}

 \begin{lstlisting}[language=Ruby, caption={Tworzenie obiektu Rgeo z zapisu binarnego danych przestrzennych}, label=lst:coordinates_helper]
module CoordinatesHelper
  FACTORY = RGeo::Geographic.spherical_factory(:srid => 4326)

  # utworzenie obiektu Rgeo z binarnego zapisu danych przestrzennych
  def coordinates_object
    RGeo::WKRep::WKBParser.new(FACTORY, support_ewkb: true,
        default_srid: 4326).parse(coordinates)
  end

  # rzutowanie obiektu przestrzennego do postaci "well known text"
  def coordinates_text
    coordinates_object.as_text
  end
end
\end{lstlisting}

\subsection{Prezentowanie danych}

Framework Ruby on Rails posiada biblioteki do integracji obu narzędzi do prezentacji danych geograficznych wspomnianych w rozdziale \ref{sec:maps-tools}:
\begin{enumerate}
  \item{leaflet-rails} - dołącza do projektu Ruby on Rails bibliotekę leafletjs napisaną w języku javascript wraz ze stylami oraz dodaje metody do widoków pozwalające na dołączenie mapy i podstawową konfiguracje bez potrzeby używania javascriptu
  \item{Google Maps for Rails} - biblioteka opakowuje javascriptową bibliotekę google maps, ułatwiając jej dodanie do projektu
\end{enumerate}
Dzięki takiej integracji zgodnie z konwencją w języku Ruby\cite{doc_ruby}  wspomniane bilbioteki są przechowywane centralnie w systemie zamiast w projekcie.
Hanami w przeciwieśtwie do Ruby on Rails nie posiada bibliotek wspomagających dołączenie do projektu biblioteki leafletjs lub Google Maps. Żeby skorzystać jednej z wymienionych bibliotek należy dołączyć jej kod do projektu.

Przy odczycie danych w formacie JSON, Ruby on Rails automatycznie serializuje model do postaci JSON. W projekcie wykorzystującym Hanami, niezbędne jest dodanie zewnętrznej bilbioteki realizującej serializowanie danych np. \textit{Roar} i zdefiniowanie odpowiedniego reprezentera. Przykładowy reprezenter został zaprezentowany na listingu \ref{lst:representer}

 \begin{lstlisting}[language=Ruby, caption={Reprezenter dla modelu Point}, label=lst:representer]
require 'roar/decorator'
require 'roar/json'

module Web::Representers
  class Point < Roar::Decorator
    include Roar::JSON

    property :id
    property :name
    property :object_type
    property :object_class
    property :voivodeship
    property :county
    property :commune
    property :terc
    property :coordinates_text
    property :color
  end
end
\end{lstlisting}

\subsection{Podsumowanie}

Ruby on Rails posiada zdecydowanie więcej gotowych narzędzi do pracy z danymi geograficznymi. Tworzenie aplikacji dzięki temu trwa mniej czasu. Implementacja systemu informacji geograficznej za pomocą frameworku Hanami wymaga od programisty znacznie więcej pracy i większych umiejętności programistycznych.

\section{Porównianie struktur wykonanych projektów}

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [rails\_project
        [app
          [assets
            [javascripts
              [application.js 17, file]
              [checkboxes.js 72, file]
              [line\_form.js 33, file]
              [lines.js 38, file]
              [point\_form.js 33, file]
              [points.js 65, file]
              [polygon\_form.js 33, file]
              [polygons.js 36, file]
              [map.js 41, file]
            ]
            [stylesheets
              [application.scss 54, file]
            ]
          ]
          [controllers
            [application\_controller.rb 3, file]
            [lines\_controller.rb 50, file]
            [maps\_controller.rb 7, file]
            [points\_controller.rb 56, file]
            [polygons\_controller.rb 50, file]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [models
          [concerns
            [gis\_support.rb 15, file]
          ]
          [application\_record.rb 3, file]
          [line.rb 23, file]
          [point.rb 32, file]
          [polygon.rb 18, file]
        ]
        [views
          [layouts
            [application.html.erb 12, file]
          ]
          [maps
            [index.html.erb 91, file]
          ]
          [shared
            [\_line\_form.erb 11, file]
            [\_point\_form.html.erb 16, file]
            [\_polygon\_form.html.erb 13, file]
          ]
        ]
      ]
    \end{forest}
  \end{minipage}
  
    
  \caption{Struktura projektu Rails}
  \label{fig:rails_proj_structure}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [hanami\_project
        [apps
          [web
            [assets
              [javascripts
                [application.js 17, file]
                [checkboxes.js 63, file]
                [leaflet.js 5, file]
                [line\_form.js 58, file]
                [lines.js 39, file]
                [point\_form.js 59, file]
                [points.js 66, file]
                [polygon\_form.js 60, file]
                [polygons.js 37, file]
                [map.js 41, file]
              ]
              [stylesheets
                [leaflet.css 548, file]
                [main.css.scss 34, file]
              ]
            ]
            [templates
              [map
                [index.html.erb 86, file]
              ]
              [shared
                [\_line\_form.html.erb 22, file]
                [\_point\_form.html.erb 42, file]
                [\_polygon\_form.html.erb 26, file]
              ]
              [application.html.erb 30, file]
            ]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [controllers
          [lines
            [create.rb 31, file]
            [destroy.rb 9, file]
            [index.rb 23, file]
            [update.rb 30, file]
          ]
          [points
            [create.rb 37, file]
            [destroy.rb 9, file]
            [index.rb 24, file]
            [update.rb 36, file]
          ]
          [polygons
            [create.rb 32, file]
            [destroy.rb 9, file]
            [index.rb 23, file]
            [update.rb 32, file]
          ]
          [map
            [index.rb 7, file]
          ]
        ]
        [representers
          [line.rb 12, file]
          [point.rb 17, file]
          [polygon.rb 13, file]
        ]
        [views
          [map
            [index.rb 26, file]
          ]
          [application\_layout.rb 7, file]
        ]
        [application.rb 65, file]
      ]
    \end{forest}
  \end{minipage}
  
    
  \caption{Struktura projektu Rails}
  \label{fig:rails_proj_structure}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [hanami\_project
      [lib
        [web
          [entities
            [line.rb 16, file]
            [point.rb 19, file]
            [polygon.rb 15, file]
          ]
          [repositories
            [concerns
              [coordinates\_helper.rb 10, file]
              [gis\_support.rb 16, file]
            ]
            [line\_repository.rb 7, file]
            [point\_repository.rb 7, file]
            [polygon\_repository.rb 7, file]
          ]
        ]
        [postgres\_inferrer.rb 8, file]
      ]
    ]
  \end{forest}   
  \caption{Struktura projektu Rails}
  \label{fig:rails_proj_structure}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [roda\_project
        [assets
          [js
            [application.js 17, file]
            [checkboxes.js 63, file]
            [leaflet.js 5, file]
            [line\_form.js 58, file]
            [lines.js 39, file]
            [point\_form.js 59, file]
            [points.js 66, file]
            [polygon\_form.js 60, file]
            [polygons.js 37, file]
            [map.js 41, file]
          ]
          [css
            [leaflet.css 548, file]
            [main.css.scss 34, file]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [models
          [concerns
            [gis\_support.rb 16, file]
          ]
          [line.rb 20, file]
          [point.rb 23, file]
          [polygon.rb 19, file]
        ]
        [routes
          [lines.rb 47, file]
          [points.rb 47, file]
          [polygons.rb 47, file]
        ]
        [views
          [shared
            [\_line\_form.erb 12, file]
            [\_point\_form.erb 17, file]
          ]
          [index.erb 92, file]
          [layout.erb 14, file]
        ]
        [app.rb 33, file]
        [models.rb 24, file]
      ]
    \end{forest}
  \end{minipage}  
  \caption{Struktura projektu Roda}
  \label{fig:roda_proj_structure}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}
%     \begin{axis}[
%       width = 0.8\linewidth,
%       height = 0.5\linewidth,
%       ybar=8pt,
%       enlarge x limits=0.15,
%       ymin=0,
%       xtick=none,
%       legend pos=outer north east,
%       ylabel={Liczba plików},
%       nodes near coords,
%       nodes near coords align={vertical},
%       compat=1.8]
%       \addplot coordinates {(,1), (,2), (,3) };
%       \legend{hanami, rails, roda}
%     \end{axis}
%   \end{tikzpicture}
%   \caption{Liczba plików w projekcie w zależności od użytego frameworka}
%   \label{fig:files_count}
% \end{figure}

\section{Porównianie  wydajności zaimplemetowanych aplikacji}
\subsection{Interfejs użytkownika}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_point_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_point_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_point_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_point_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla punktu}
  \label{fig:crud_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend pos=outer north east,
      xlabel={Liczba punktów na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_points_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_points_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_points_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w zależności od liczby punktów}
  \label{fig:read_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_line_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_line_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_line_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_line_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:crud_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_lines_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_lines_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_lines_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w zależności od liczby linii}
  \label{fig:read_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_polygon_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_polygon_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_polygon_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_polygon_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:crud_polygons}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_polygons_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_polygons_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_polygons_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w zależności od liczby wielokątów}
  \label{fig:read_polygons}
\end{figure}

\subsection{Zapytania HTTP}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_point_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_point_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_point_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_point_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania zapytania HTTP dla punktu}
  \label{fig:http_crud_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend pos=outer north east,
      xlabel={liczba punktów},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_points_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_points_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_points_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby punktów}
  \label{fig:http_read_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_point_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_point_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_point_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby użytkowników}
  \label{fig:load_avg_time_point}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={liczba użytkowników},
      ylabel={liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_point_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_point_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_point_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{liczba obsłużonych zapytań na sekunde w zależności od liczby użytkowników}
  \label{fig:load_rps_point}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/http/rails_crud_line_http_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_line_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_line_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_line_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:http_crud_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={liczba linii na mapie},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_lines_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_lines_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_lines_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby linii}
  \label{fig:http_read_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_line_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_line_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_line_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby użytkowników}
  \label{fig:load_avg_time_line}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={liczba użytkowników},
      ylabel={liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_line_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_line_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_line_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{liczba obsłużonych zapytań na sekunde w zależności od liczby użytkowników}
  \label{fig:load_rps_line}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/http/rails_crud_polygon_http_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_polygon_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_polygon_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_polygon_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:http_crud_polygons}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_polygons_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_polygons_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_polygons_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby wielokątów}
  \label{fig:http_read_polygons}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_polygon_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_polygon_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_polygon_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w zależności od liczby użytkowników}
  \label{fig:load_avg_time_polygon}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={liczba użytkowników},
      ylabel={liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_polygon_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_polygon_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_polygon_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot table[x index={0}, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{liczba obsłużonych zapytań na sekunde w zależności od liczby użytkowników}
  \label{fig:load_rps_polygon}
\end{figure}

\subsection{Komunikacja z bazą danych}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_point_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_point_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_point_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_point_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla punktu}
  \label{fig:model_crud_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend pos=outer north east,
      xlabel={Liczba punktów na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_points_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_points_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_points_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z bazy w zależności od liczby punktów}
  \label{fig:model_read_points}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_line_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_line_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_line_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_line_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:model_crud_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_lines_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_lines_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_lines_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z bazy w zależności od liczby linii}
  \label{fig:model_read_lines}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=8pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_polygon_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_polygon_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_polygon_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_polygon_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:model_crud_polygons}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_polygons_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_polygons_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_polygons_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot table[x=count, y=time] {\rodatable};
      \legend{hanami, rails, roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z bazy w zależności od liczby wielokątów}
  \label{fig:model_read_polygons}
\end{figure}

\chapter{Podsumowanie}
\section{Analiza wyników badań}
\emph{który framework jest najbardziej wydajny w~rozpatrywanych przypadkach}

\section{Realizacja celu projektu}
\emph{czy cel projektu został zrealizowany, napotkane trudności/przeszkody}

\begin{thebibliography}{inz}
  \addcontentsline{toc}{chapter}{Literatura}

  \bibitem{doc_georuby}
  \emph{Dokumentacja biblioteki GeoRuby}, dostępna pod adresem:\\ \url{https://github.com/nofxx/georuby}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_google}
  \emph{Dokumentacja biblioteki Google Maps JavaScript API}, dostępna pod adresem:\\ \url{https://developers.google.com/maps/documentation/javascript/}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_leaflet}
  \emph{Dokumentacja biblioteki Leaflet}, dostępna pod adresem:\\ \url{http://leafletjs.com/reference-1.0.3.html}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_rgeo}
  \emph{Dokumentacja biblioteki Rgeo}, dostępna pod adresem:\\ \url{https://github.com/rgeo/rgeo}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_hanami}
  \emph{Dokumentacja Hanami}, dostępna pod adresem:\\ \url{http://hanamirb.org/guides/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_ruby}
  \emph{Dokumentacja języka Ruby}, dostępna pod adresem:\\ \url{https://www.ruby-lang.org/pl/documentation/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_mango}
  \emph{Dokumentacja MangoMap}, dostępna pod adresem:\\ \url{http://help.mangomap.com/}, aktualne na dzień 22.04.2017r.

  \bibitem{doc_mysql}
  \emph{Dokumentacja MySQL}, dostępna pod adresem:\\ \url{https://dev.mysql.com/doc/refman/5.7/en/}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_osm}
  \emph{Dokumentacja OpenStreetMap}, dostępna pod adresem:\\ \url{http://wiki.openstreetmap.org/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_postgresql}
  \emph{Dokumentacja PostgreSQL}, dostępna pod adresem:\\ \url{https://www.postgresql.org/docs/9.6/static/index.html}, aktualne na dzień 09.06.2017r.

  \bibitem{doc_postgis}
  \emph{Dokumentacja PostGIS}, dostępna pod adresem:\\ \url{http://postgis.net/documentation/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_rails}
  \emph{Dokumentacja Ruby on Rails}, dostępna pod adresem:\\ \url{http://guides.rubyonrails.org/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_roda}
  \emph{Dokumentacja Roda}, dostępna pod adresem:\\ \url{http://roda.jeremyevans.net/documentation.html}, aktualne na dzień 01.06.2017r.

  \bibitem{doc_spatialite}
  \emph{Dokumentacja SpatiaLite}, dostępna pod adresem:\\ \url{https://www.gaia-gis.it/fossil/libspatialite/index}, aktualne na dzień 09.06.2017r.

  \bibitem{principles_gis}
  Huisman Otto, By (de) Rolf A., \emph{Principles of Geographic Information Systems}, ITC, 2009

  \bibitem{clean_architecture}
  Martin Robert, \emph{The Clean Architecture}, dostępna pod adresem:\\ \url{https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html}, aktualne na dzień 20.04.2017r.

  \bibitem{rails_agile}
  Ruby Sam, Thomas Dave, Hansson Heinemeier David, \emph{Agile Web Development with Rails 5}, Pragmatic Programmers, 2016

  \bibitem{gis_introduction}
  Schmandt Michael, \emph{GIS Commons: An Introductory Textbook on Geographic Information Systems}, dostępne pod adresem:\\
  \url{http://giscommons.org/}, aktualne na dzień 07.04.2017r.

  \bibitem{framework}
  Smyrdek Przemysław, \emph{Czym jest framework i~po co go używać}, dostępne pod adresem:\\
  \url{http://poznajprogramowanie.pl/czym-jest-framework-i-po-co-go-uzywac/}, aktualne na dzień 20.04.2017r.
  
  
 
\end{thebibliography}

\end{document}
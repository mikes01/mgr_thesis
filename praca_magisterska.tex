\documentclass[printmode]{mgr}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fontenc}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{psfrag}
\usepackage{supertabular}
\usepackage{array}
\usepackage{hhline}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{enumitem}
\usepackage{afterpage}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color, colortbl}
\usepackage{hyphenat}
\usepackage[hidelinks]{hyperref}
\usepackage{ucs}
\usepackage{makecell}
\usepackage[edges]{forest}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}

\def\Size{4pt}
\tikzset{%
  folder/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);
    \filldraw [draw=folderborder, top color=folderbg!50, bottom color=folderbg] (-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
  },
  file/.pic={%
    \filldraw [draw=folderborder, top color=folderbg!5, bottom color=folderbg!10] (-\Size,.4*\Size+5pt) coordinate (a) |- (\Size,-1.2*\Size) coordinate (b) -- ++(0,1.6*\Size) coordinate (c) -- ++(-5pt,5pt) coordinate (d) -- cycle (d) |- (c) ;
  },
}

\forestset{%
  declare autowrapped toks={pic me}{},
  pic dir tree/.style={%
    for tree={%
      folder,
      font=\ttfamily,
      grow'=0,
    },
    before typesetting nodes={%
      for tree={%
        edge label+/.option={pic me},
      },
    },
  },
  pic me set/.code n args=2{%
    \forestset{%
      #1/.style={%
        inner xsep=2\Size,
        pic me={pic {#2}},
      }
    }
  },
  pic me set={directory}{folder},
  pic me set={file}{file},
}

\makeatletter
\pgfplotsset{
    /pgfplots/flexible xticklabels from table/.code n args={3}{%
        \pgfplotstableread[#3]{#1}\coordinate@table
        \pgfplotstablegetcolumnbyindex{#2}\of{\coordinate@table}\to\pgfplots@xticklabels
        \let\pgfplots@xticklabel=\pgfplots@user@ticklabel@list@x
    }
}
\makeatother
\raggedbottom

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{lightgreen}{RGB}{153,255,153}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}

\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, \$scope},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{mymauve}\ttfamily,
  sensitive=true
}

\lstdefinelanguage{Slim}{
  keywords={ul, div, a, href, i, li},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{mymauve}\ttfamily,
  sensitive=true,
}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  frame=single,  
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,
  inputencoding=utf8x, 
  extendedchars=\true,
  literate={ą}{{\k{a}}}1
  {Ą}{{\k{A}}}1
  {ę}{{\k{e}}}1
  {Ę}{{\k{E}}}1
  {ó}{{\'o}}1
  {Ó}{{\'O}}1
  {ś}{{\'s}}1
  {Ś}{{\'S}}1
  {ł}{{\l{}}}1
  {Ł}{{\L{}}}1
  {ż}{{\.z}}1
  {Ż}{{\.Z}}1
  {ź}{{\'z}}1
  {Ź}{{\'Z}}1
  {ć}{{\'c}}1
  {Ć}{{\'C}}1
  {ń}{{\'n}}1
  {Ń}{{\'N}}1
}

\newcommand\blankpage{%
  \null
  \thispagestyle{empty}%
  \addtocounter{page}{-1}%
  \newpage}

\addto\extraspolish{\def\bibname{Literatura}\let\refname\bibname}
\renewcommand{\lstlistingname}{Fragment kodu}
\renewcommand\lstlistlistingname{Spis fragmentów kodu}

\date{2017}

\title{Analiza porównawcza frameworków internetowych w~języku Ruby w~zastosowaniach GISowych}
\engtitle{Comparative analysis of Ruby's web frameworks for Geographic Information Systems}
\author{inż. Mikołaj Grygiel}
\supervisor{dr inż. Roman Ptak, W4/K9}

\field{Informatyka (INF)}
\specialisation{ Inżynieria systemów informatycznych (INS)}

\begin{document}
\bibliographystyle{plabbrv}

\maketitle

\tableofcontents

\listoffigures
\lstlistoflistings
\addcontentsline{toc}{chapter}{\listfigurename}
\addcontentsline{toc}{chapter}{\lstlistlistingname}

\chapter{Wprowadzenie}
\section{Cel pracy}
Język Ruby zajmuję 12. miejsce w~rankingu popularności języków programowania \emph{Tiobe}\footnote{Dane z~marca 2017 r. dostępne na stronie https://www.tiobe.com/tiobe-index/}. Dużą popularnością wśród frameworków internetowych cieszy się Ruby on Rails, w~rankingu \emph{Hotframeworks}\footnote{Ranking https://hotframeworks.com bierzę pod uwagę liczba repozytoriów kodu na platformie Github i~ilość tematów na forum Stackoverflow dotyczących danego frameworku. Dane z~dnia 26.03.2017 r.} zajmuję 3 miejsce wśród wszystkich frameworków. Ruby on Rails jest bez wątpienia najpopularniejszym frameworkiem w~języku Ruby, kolejne dwa frameworki w~języku Ruby to Sinatra i~Hanami, zajmują w~wcześniej przytoczonym rankingu odpowiednio miejsca 25. i~73. Jednak w~języku Ruby istnieje kilkanaście frameworków przeznaczonych do budowania aplikacji internetowych.

Celem niniejszej pracy jest poznanie wybranych frameworków w~języku Ruby, ich porównanie w~konkretnym zastosowaniu jakim są systemy informacji geograficznej oraz odpowiedź na pytanie jaki framework najlepiej wybrać do tworzenia systemu GIS.

\section{Zakres i~koncepcja pracy}
,,Framework'' można zdefiniować jako szkielet służący do budowania aplikacji, czyli zbiór gotowych rozwiązań powtarzających się problemów i~wzór do budowania nowych funkcjonalności. \cite{framework}

W niniejszej pracy zostaną omówione wybrane frameworki w~języku Ruby w~świetle ich użyteczności przy budowie systemu informacji geograficznej. Frameworki zostaną porównane na podstawie informacji zawartych w~dostępnej dokumentacji narzędzia oraz zaimplementowanej przykładowej aplikacji, za pomocą każdego z~wybranych narzędzi, spełniającej wymagania systemu GIS.


\chapter{Podstawy teoretyczne}

\section{Charakterystyka Systemów Informacji Geograficznej}
System Informacji Geograficznej skrótowo nazywany GIS (ang. \textit{Geographic Information System}) można zdefiniować na wiele sposobów. Michael Schmandt w~swoim opracowaniu \cite{gis_introduction} podaje następujące definicje:

\paragraph*{Definicja 1.}
GIS to system komputerowy składający się z~sprzętu i~oprogramowania oraz ludzie, którzy wspomagają zbieranie, zarządzanie, analizowanie i~wyświetlanie danych przestrzennych. Stosując tą definicje możemy podzielić system GIS na 4 moduły:

  \begin{itemize}
    \item Moduł wprowadzania danych - zawiera narzędzia pozwalające na wprowadzania i~przechowywanie danych przestrzennych.
    \item Moduł zarządzania danymi - ta część umożliwia edytowanie oraz przeglądanie zgromadzonych zbiorów danych.
    \item Moduł analizowania danych - podsystem, który odpowiada za analizowanie danych geograficznych i~wyciąganie z~nich informacji.
    \item Moduł prezentowania danych - pozwala na tworzenie map, modeli i statystyk ilustrujących zgromadzone dane.
  \end{itemize}

\paragraph*{Definicja 2.}
System informacji geograficznej to system komputerowy, który pozwala na przechowywanie danych powiązanych ze sobą geograficznie.

\paragraph*{Definicja 3.}
GIS to narzędzie do wyszukiwania wzorców geograficznych (przestrzennych) w~zbiorach danych.

Pierwsza definicja jest najbardziej szeroka i~zawiera w~sobie dwie następne - definicja druga to dwa pierwsze moduły z~\textbf{Definicja 1.}, a~definicja trzecia to moduł analizowania danych.

W podobny sposób do definicji nr 1 GIS jest zdefiniowany w~\emph{Principles of Geographic Information Systems} \cite{principles_gis} jako zbiór narzędzi pozwalających operować na danych reprezentujących zjawiska geograficzne. Zbiór ten dzieli się na 4 grupy ze względu na funkcje:
  \begin{itemize}
    \item zbieranie i~przygotowywanie danych,
    \item zarządzanie i~przechowywanie danych,
    \item analiza danych,
    \item prezentowanie danych.
  \end{itemize}

W poniższej pracy przyjmuje się pierwszą definicje Systemu Informacji Geograficznego - GIS to system informatyczny służący do wprowadzania, przechowywania, zarządzania, analizowania i~prezentacji danych przestrzennych.

\section{Charakterystyka języka Ruby}
Język Ruby został wydany w~1995 roku. Twórca Rubiego, Yukihiro ,,Matz'' Matsumoto, inspirował się takimi językami programowani jak Perl, Smalltalk, Eiffel, Ada i~Lisp by stworzyć jego zdaniem język, który zbalansuje programowanie funkcjonalne z~programowanie imperatywnym. \cite{doc_ruby} Składnia Rubiego ma przypominać język naturalny, autor języka opisuje go jako: \emph{Ruby jest prosty z~wyglądu, ale bardzo skomplikowany w~środku, tak jak ciało ludzkie.}\footnote{Wypowiedź w~liście ruby-talk 12.05.2000 r., źródło: \\http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/2773}

Ruby jest językiem ściśle obiektowym, wszystko postrzegane jest jako obiekt. Każda funkcja jest metodą, ponieważ musi być przyłączona do jakiegoś obiektu. Ruby posiada celowo tylko jednokrotne dziedziczenie, ale pozwala na dołączanie wielu modułów, które są zbiorami metod do klasy. Ruby jest bardzo elastycznym językiem, pozwala na usunięcie lub przedefiniowanie dowolnej swojej części. Mimo silnie obiektowej natury, dostępne są również elementy programowania funkcyjnego takie jak funkcje anonimowe lub domknięcia.

Szerszą popularność Ruby zyskał w~2006 r., 11 lat po publikacji. Swoją popularność zawdzięcza głównie frameworkowi Ruby on Rails. w~rankingu popularności języków programowania Tiobe znajduje się aktualnie na 12 miejscu\footnote{Dane z~dnia 08.04.2017 r. https://www.tiobe.com/tiobe-index/}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/ruby_tiobe}
  \caption{Histora popularności języka Ruby według rankingu Tiobe}
  \label{fig:ruby_tiobe}
\end{figure}

\chapter{Istniejące systemy GIS w~języku Ruby}

\section{OpenStreetMap}

  OpenStreetMap jest internetowym systemem informacji geograficznej z~otwartym kodem źródłowym. System zbudowany z~wykorzystaniem bazy danych PostgreSQL, frameworku Ruby on Rails oraz biblioteki JavaScriptowej Leaflet służącej do tworzenia interaktywnych widoków z~mapami. Dostęp do danych jest otwarty, dane mogą być edytowane przez dowolnego użytkownika, dlatego mogą być niezgodne z~rzeczywistością. OpenStreetMap definiuje 4 typy obiektów przestrzennych \cite{doc_osm}:
  \begin{itemize}
    \item Węzeł (ang. \textit{node}) - pojedynczy punkt przestrzenny reprezentowany przez długość i~szerokość geograficzną.
    \item Linia (ang. \textit{way}) - jest to uporządkowany zbiór punktów, które mogą reprezentować funkcje liniowe(wektory) lub obszary.
    \item Relacja (ang. \textit{relation}) - składa się z~uporządkowanej listy węzłów, linii i~innych relacji.
    \item Tag (ang. \textit{tag}) - to jednostka informacji dołączona do obiektu jednego z~powyżej opisanych typów. Tag składa się z~klucza oraz wartości. 
  \end{itemize}

  OpenStreetMap można wykorzystać przez utworzenie komponentu HTML z~wybraną mapą, gotowego do zamieszczenia na dowolnej stronie internetowej lub przez pobranie danych z~wybranej mapy. Skompresowane aktualne dane dla całej planety z~pojedynczego dnia zajmują prawie 40 GB. Można pobierać również dane historyczne.

\section{MangoMap}

  MangoMap jest komercyjnym narzędziem do tworzenia map dostępnych przez internet z~własnych danych przestrzennych. Ceny za korzystanie z~serwisu wynoszą 49-399\$ miesięcznie w~zależności od liczby map i~udostępnianego miejsca na serwerze do przechowywania danych. System zbudowany jest w~oparciu o~framework Ruby on Rails. Mapy tworzy się przy użyciu interfejsu graficznego. Stworzone mapy mogą być udostępnione na serwerze MangoMap przez unikalny link lub zamieszczone na zewnętrznej stronie WWW przez komponent HTML. \cite{doc_mango}

\chapter{Frameworki internetowe w~języku Ruby}

W języku Ruby istnieje kilkanaście wspieranych frameworków internetowych. Wybór wykorzystanych frameworków w~niniejszej pracy dokonano w~następujący sposób:
  \begin{enumerate}
    \item Podzielono frameworki według daty opublikowania pierwszej wersji na 3 grupy:
    \begin{enumerate}
      \item Opublikowane w~latach 2004 - 2011 - frameworki o~ugruntowanej pozycji.
      \item Opublikowane w~latach 2012 - 2015 - stosunkowo nowe frameworki.
      \item Opublikowane w~latach 2016 - 2017 - najnowsze frameworki.
    \end{enumerate}
    \item Z~każdej grupy wybrano framework z~największą liczbą pobrań.
  \end{enumerate}
Ta metoda ma na celu wyłonienie najpopularniejszych frameworków, które powstały w~różnych etapach języka Ruby, jednocześnie każdy z~nich współpracuje z~najnowszą wersją języka. w~ten sposób wybrano \emph{Ruby on Rails, Roda i~Hanami.}


\begin{table}[H]
  \caption{ Frameworki internetowe w~języku Ruby \protect\footnotemark}
  \centering
  \begin{tabularx}{1\linewidth}{|X|X|X|r|} \hline
    Nazwa & Data opublikowania \newline pierwszej wersji & Data opublikowania \newline  najnowszej wersji & Liczba pobrań \\ \hline
    \rowcolor{lightgray}
    Ruby on Rails & 25.10.2004 r. & 20.03.2017 r. & 91 898 706 \\ \hline
    Hobo & 29.04.2007 r. & 07.05.2016 r. & 211 042 \\ \hline
    Sinatra & 04.10.2007 r. & 19.03.2017 r. & 45 207 501 \\ \hline
    Padrino & 16.11.2009 r. & 23.03.2017 r. & 556 481 \\ \hline
    Cuba & 25.04.2010 r. & 01.07.2016 r. & 124 371 \\ \hline
    Strelka & 24.08.2011 r. & 19.01.2017 r. & 57 007 \\ \hline
    Pakyow & 20.09.2011 r. & 15.07.2016 r. & 18 222 \\ \Xhline{4\arrayrulewidth}
    Scorched & 03.03.2013 r. & 12.10.2016 r. & 26 929 \\ \hline
    Trailblazer & 26.07.2013 r. & 23.01.2017 r. & 96 217 \\ \hline
    \rowcolor{lightgray}
    Roda & 20.07.2014 r. & 15.03.2017 r. & 105 103 \\ \hline
    Vanilla & 09.05.2015 r. & 05.07.2016 r. & 80 125 \\ \Xhline{4\arrayrulewidth}
    \rowcolor{lightgray}
    Hanami & 20.01.2016 r. & 06.04.2017 r. & 28 885 \\ \hline
    Dry-web & 21.04.2016 r. & 02.02.2017 r. & 7 190 \\ \hline
  \end{tabularx}
\end{table}
\footnotetext{Zestawienia przygotowano na podstawie danych z~https://rubygems.org/ oraz \\ https://www.ruby-toolbox.com. Pominięto frameworki, których ostatnia wersja ukazała się ponad rok temu. Aktualne na dzień 08.04.2017 r.}

\section{Ruby on Rails}

Pierwsza stabilna wersja (1.0.0) frameworku Ruby on Rails ukazała się pod koniec 2005 roku, aktualna wersja (5.0.2) została opublikowana 02.03.2017 r. Aplikacja zbudowana z~wykorzystanie RoR jest oparta o~wzorzec projektowy Model-Widok-Kontroler \cite{rails_agile} (ang. \textit{Model-View-Controller}). Aplikacja oparta na tym wzorcu jest podzielona na 3 części:
\begin{itemize}
  \item Modele (ang. \textit{model}) - reprezentują logikę biznesową. w~tej warstwie znajdują się wszelkie obiekty, które służą do wykonywania operacji związanych z~implementacją funkcjonalności aplikacji.
  \item Widoki (ang. \textit{view}) - służą do prezentowania danych. 
  \item Kontrolery (ang. \textit{controller}) - obsługują zapytania użytkownika. Nie zawierają w~sobie żadnej logiki biznesowej.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/rails_mvc}
  \caption{Architektura aplikacji w~Ruby on Rails, źródło: http://blog.ifuturz.com/ruby-on-rails/ruby-on-rails-mvc-learn-with-fun.html}
  \label{fig:rails_mvc}
\end{figure}
\newpage
Dwie główne zasady frameworku \cite{doc_rails}:

\begin{itemize}
  \item Nie powtarzaj się (ang. \textit{Don't Repeat Yourself}) - każda informacja powinna mieć pojedynczą, jednoznaczną i~autorytatywną reprezentacje w~kodzie źródłowym systemu. Ułatwia to utrzymywanie kodu.
  \item Konwencja ponad konfiguracje (ang. \textit{Convention Over Configuration}) - RoR posiada ustalone zasady postępowania w~różnych przypadkach. Aplikacja domyślnie zachowuje się według tych zasad, nie wymagając dodatkowej konfiguracji. Pozwala to zredukować ilość kodu źródłowego.
\end{itemize}


\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [app
        [controllers]
        [models]
        [views]
      ]
    ]
  \end{forest}
  \caption{Podstawowa struktura projektu Ruby on Rails}
  \label{fig:rails_structure}
\end{figure}

\section{Roda}

Twórcy frameworku Roda jest przy tworzeniu narzędzia podstawili sobie 4 cele \cite{doc_roda}:
  \begin{itemize}
    \item Prostota (ang. \textit{simplicity}) - framework ma być prosty zarówno wewnątrz (w implementacji), jak i~na zewnątrz (dla użytkowników).
    \item Niezawodność (ang. \textit{reliability}) - Roda wspiera i~promuje projektowanie aplikacji z~niemutowanym stanem. Roda ogranicza zmienne, stałe i~metody przypisane do instancji obiektów aby uniknąć konfliktów z~kodem zaimplementowanym przez użytkownika.
    \item Rozszerzalność (ang. \textit{extensibility}) - framework zbudowany jest całkowicie w~oparciu o~wtyczki, aby ułatwić dodawanie funkcjonalności do frameworka. Każda część Rody może być zastąpiona własną implementacją przez użytkownika.
    \item Wydajność (ang. \textit{performance}) - Roda posiada mały koszt obsługi zapytań, drzewo trasowania i~inteligentną obsługę pamięci podręcznej co sprawia, że Roda jest szybsza od innych popularnych frameworków języka Ruby.
  \end{itemize}
Roda opiera się o~drzewo trasowania, punkty dostępu aplikacji zdefiniowane są w~strukturze drzewa. Przykład drzewa trasowań znajduje się we fragmencie kodu \ref{lst:routing_tree}.

\newpage
\begin{lstlisting}[language=Ruby, caption={Proste drzewo trasowań}, label=lst:routing_tree]
r.on "a" do           # /a gałęź
  r.on "b" do         # /a/b gałęź
    r.is "c" do       # /a/b/c zapytanie
      r.get do end    # GET  /a/b/c zapytanie
      r.post do end   # POST /a/b/c zapytanie
    end
    r.get "d" do end  # GET  /a/b/d zapytanie
    r.post "e" do end # POST /a/b/e zapytanie
  end
end
\end{lstlisting}

W przeciwieństwie do Ruby on Rails, Roda nie posiada warstwy kontrolerów i~osobnego modułu obsługującego trasowanie, w~Rodzie przy definicji danego punktu końcowego znajduje się od razu kod obsługujący otrzymane zapytanie.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/roda_architecture}
  \caption{Architektura aplikacji w~frameworku Roda}
  \label{fig:roda_architecture}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [models]
      [routes]
      [views]
    ]
  \end{forest}   
  \caption{Struktura projektu Roda}
  \label{fig:roda_structure}
\end{figure}

\section{Hanami}

Hanami jest lekkim frameworkiem internetowym opartym o~architekturę MVC, zbudowanym z~wielu mikro-bibliotek. W~przeciwieństwie do Ruby on Rails, Hanami nie stawia konwencji ponad konfiguracje, wszystkie informacje powinny być zawarte w~napisanym przez programistę kodzie, którego zrozumienie nie wymaga znajomości konwencji frameworka. Architektura projektu jest głównie inspirowana przez dwa podejścia:

\begin{itemize}
  \item Czysta architektura (ang. \textit{clean architecture}) - schemat tej architektury składa się z~kolejnych zawierających się w~sobie kół. Każde wewnętrzne koło nie ma żadnych zależności w~zewnętrznym kole, czyli w~obiektach należących do wewnętrznego koła, nie ma odwołań do obiektów z~zewnętrznych kół. \cite{clean_architecture} To podstawowa zasada tego podejścia. 

  \begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{pictures/clean_architecture}
    \caption{Schemat czystej architektury \cite{clean_architecture}}
    \label{fig:clean_architecture}
  \end{figure}

  Na schemacie \ref{fig:clean_architecture} można wyróżnić 4 byty:

  \begin{itemize}
    \item Encje (ang. \textit{entities}) - zawierają ogólne reguły biznesowe systemu. Mogą być reprezentowane przez obiekty z~metodami, struktury danych lub pojedyncze funkcje.
    \item Przypadki użycia (ang. \textit{use cases}) - ta warstwa skupia w~sobie wszystkie możliwe przypadki użycia systemu przez użytkownika. Znajduje się tu cała logika biznesowa zarządzania encjami. Zmiana w~tej warstwie nie powinna wpływać na encje, interfejs użytkownika lub bazę danych.
    \item Adaptery interfejsów (ang. \textit{interface adapters}) - na tym poziomie dane są konwertowane z~formatu najbardziej dogodnego dla przypadków użycia i~encji do formatu przyjmowanego przez zewnętrzne narzędzia takie jak baza danych lub przeglądarka internetowa. 
    \item Frameworki oraz narzędzia (ang. \textit{frameworks and drivers}) - w~tej warstwie znajdują się zewnętrzne narzędzia takie jak inne frameworki, baza danych lub przeglądarka internetowa.
  \end{itemize}

  \item Najpierw monolit (ang. \textit{monolith first}) - według tej zasady budowę systemu zaczyna się od monolitycznej aplikacji. Jednak budowa aplikacji od samego początku powinna być jak najbardziej modularna aby można było ją później rozbić na wiele mniejszych aplikacji.

  Zgodnie z~zasadą \emph{czystej architektury} w~utworzonym projekcie systemu z~użyciem Hanami oddzielona jest warstwa logiki biznesowej znajdująca się w~folderze \emph{lib} projektu od mechanizmu komunikacji z~innymi serwisami zawartego w~folderze \emph{apps}.

  Hanami posiada kontener aplikacji, który pozwala nam utworzyć wiele aplikacji w~ramach jednego projektu, które korzystają z~tego samego zbioru encji i~przypadków użycia, a~następnie uruchomić je w~jednym procesie Rubiego.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [project\_root
      [apps
        [web
          [controllers]
          [templates]
          [views]
        ]
      ]
      [lib
        [main
          [entities]
          [repositories]
        ]
      ]
    ]
  \end{forest}
  \caption{Podstawowa struktura projektu Hanami}
  \label{fig:hanami_structure}
\end{figure}

\chapter{Narzędzia dostępne do przetwarzania danych geograficznych w~języku Ruby}
\section{Przechowywanie danych}
Omawiane frameworki domyślnie wykorzystują relacyjną bazę danych do przechowywania informacji. Najpopularniejsze bazy danych to PostgreSQL, MySQL, SQLite.
\subsection{PostgreSQL}
PostgreSQL posiada kilka wbudowanych typów przestrzennych \cite{doc_postgresql}: 
\begin{itemize}
  \item Point - reprezentuje punkt na mapie, to podstawowy typ, który służy do budowania pozostałych typów przestrzennych. Dane zapisane są jako para współrzędnych w~postaci tekstowej \textit{( x, y )}, gdzie x i~y to liczby zmienno-przecinkowe.
  \item Line - prosta w~znaczeniu geometrycznym, mogą być reprezentowane przez równanie liniowe \textit{Ax + By + C = 0}, wtedy w~bazie danych zapisane są współczynniki \textit{A, B, C}. Innym sposobem reprezentacji tego typu są dwa punkty, przez które przechodzi prosta \textit{[ ( x1 , y1 ) , ( x2 , y2 ) ]
  }.
  \item Line Segment - w~znaczeniu geometrycznym to odcinek, reprezentowany przez dwa punkty, początek i~koniec odcinka \textit{[ ( x1 , y1 ) , ( x2 , y2 ) ]}.
  \item Box - to czworokąt zapisane jako dwa przeciwległe wierzchołki\\ \textit{( ( x1 , y1 ) , ( x2 , y2 ) )}.
  \item Path - lista połączonych ze sobą punktów, ścieżka. Ścieżka może być otwarta, jeśli pierwszy i~ostatni punkt nie są ze sobą połączone, lub zamknięta, jeśli pierwszy i~ostatni punkt są ze sobą połączone. Nawiasy kwadratowe reprezentują otwartę ścieżkę \textit{[ ( x1 , y1 ) , ... , ( xn , yn ) ]}, zamknięta ścieżka jest przedstawiona za pomocą okrągłych nawiasów \textit{( ( x1 , y1 ) , ... , ( xn , yn ) )}.
  \item Polygon - to wielokąt zapisany za pomocą listy punktów, reprezentujących kolejne wierzchołki wielokąta \textit{( ( x1 , y1 ) , ... , ( xn , yn ) )}.
  \item Circle - okrąg zapisany przy pomocy środka i~promienia \textit{  $< ( x , y ) , r >$ }.
\end{itemize}
PostgreSQL dostarcza niewiele funkcji do wyszukiwania danych. Sprawdzenie zależności między dwoma punktami takich jak np. przecięcie dwóch obiektów lub zawieranie się jednego obiektu w~drugim nie jest dostępne dla typów \textit{Path} i~\textit{Polygon}. 
\subsection{PostGIS}
PostGIS jest biblioteką rozszerzającą możliwości PostgreSQL w~zakresie przetwarzania danych przestrzennych. Biblioteka jest wspierana przez fundacje \textit{Open Source Geospatial}. \cite{doc_postgis} Dane są zapisane w~formie binarnej jako współrzędne geograficzne lub geometryczne w~zależności od wyboru. PostGIS zapewnia wsparcie typów zdefiniowanych przez \textit{Open Geospatial Consortium}:
\begin{itemize}
  \item POINT - pojedynczy punkt na mapie.
  \item LINESTRING - zbiór połączonych ze sobą punktów reprezentujący ścieżkę.
  \item POLYGON - zbiór połączonych ze sobą punktów reprezentujący wierzchołki wielokąta.
\end{itemize} 
\textit{Open Geospatial Consortium} definiuje również kolekcje obiektów powyższych typów:
\begin{itemize}
  \item MULTIPOINT - kolekcja punktów.
  \item MULTILINESTRING - kolekcja linii.
  \item MULTIPOLYGON - kolekcja wielokątów.
  \item GEOMETRYCOLLECTION - kolekcja dowolnych obiektów geometrycznych.
\end{itemize}
Dla wszystkich typów dostępny jest taki sam zestaw funkcji, które np. sprawdzają zależności między dwoma obiektami, co jest pomocne przy wyszukiwaniu obiektów.

\subsection{MySQL Spatial}
MySQL Spatial jest rozszerzeniem dla bazy MySQL, które dostarcza wsparcie dla danych przestrzennych. Rozszerzenie dostarcza typy danych zdefiniowane przez grupę \textit{Open Geospatial Consortium}. \cite{doc_mysql} Zbiór funkcjonalności pokrywa się z~funkcjonalnościami rozszerzenia Postgis.
\subsection{SpatiaLite}
SpatiaLite jest rozszerzeniem dla bazy danych SQLite, które zawiera wsparcie dla typów przestrzennych zdefiniowanych przez grupę \textit{Open Geospatial Consortium}\cite{doc_spatialite}: \textit{Point, Line, Multiline, Polygon, Multipolygon}. Cała baza danych zapisana jest w~pojedynczym pliku. Biblioteka udostępniona jest na zasadzie otwartego źródła.

\section{Obiektowe przetwarzanie danych}
\subsection{RGeo}
RGeo wspiera typy danych zdefiniowane przez \textit{Open Geospatial Consortium}, takie jak punkt, linia i~wielokąt. Dane są reprezentowane w~formie obiektowej. Biblioteka pozwala na podstawowe operacje analizowania danych przestrzennych, takie jak szukanie punktów przecięcia i~obliczenia pola powierzchni. Biblioteka operuje na reprezentacji geograficznej i~geometrycznej danych i~pozwala konwertować dane pomiędzy dostępnymi reprezentacjami. RGeo udostępnia udostępnia jedynie interfejs w~języku Ruby dla programistów, a~do obsługi danych geograficznych korzysta z~bibliotek GEOS i~proj.4, te biblioteki są napisane w~języku C++. \cite{doc_rgeo}

\subsection{GeoRuby}
GeoRuby jest biblioteką całkowicie napisaną za pomocą języka Ruby do przetwarzania danych przestrzennych. Biblioteka ściśle podąża za modelem danych definiowanych przez \textit{Open Geospatial Consortium}, dlatego dobrze łączy się z~takimi bazami danych jak Postgis, MySQL Spatial, SpatiaLite i~innymi, które również wspierają typu opracowane przez OGC. \cite{doc_georuby}

\section{Prezentowanie danych}
\label{sec:maps-tools}
\subsection{Leaflet}
Leaflet jest biblioteką napisaną w~języku JavaScript, która pozwala dodać interaktywną mapę do widoku aplikacji internetowej. Biblioteka nie dostarcza graficznej reprezentacji mapy, ale zapewnia obsługę mapy z~zewnętrznego serwisu np. OpenStreetMap. Do mapy można dodawać interaktywne obiekty. Biblioteka dostępna jest na zasadzie otwartego źródła. \cite{doc_leaflet}

\subsection{GoogleMaps JavaScript API}
GoogleMaps JavaScript API pozwala dołączyć mapę z~serwisu Google Maps. Mapa jest interaktywna i~pozwala wyświetlać obiekty dodane przez programistę. W darmowej wersji GoogleMaps API pozwala wczytać mapę 25 000 razy w~ciągu dnia. \cite{doc_google}


\chapter{Aplikacja zaimplementowana na potrzeby badań}
\section{Opis aplikacji}

W~celu wykonania analizy porównawczej w~każdym z~wybranych frameworków została zaimplementowana aplikacja internetowa operująca na danych geograficznych posiadająca takie same funkcjonalności. Aplikacje zostały zrealizowane zgodnie z~architekturą i~konwencją wykorzystywaną w~danym frameworku zawartych w~dokumentacji narzędzia. W projektach wykorzystano jedynie biblioteki niezbędne do zrealizowania wymaganych funkcjonalności. Nie używano bibliotek modyfikujących architekturę aplikacji lub funkcjonalności frameworka.
Aplikacja ma za zadanie wykonywać 4 podstawowe operacje na danych geograficznych:
\begin{itemize}
  \item tworzenie,
  \item odczytywanie,
  \item aktualizowanie,
  \item usuwanie.
\end{itemize}

Wszystkie funkcjonalności wykonanej aplikacji zostały zaprezentowane na rysunku \ref{fig:use_cases}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/use_cases}
  \caption{Diagram przypadków użycia aplikacji}
  \label{fig:use_cases}
\end{figure}

Aby przeprowadzić badania w~realistycznych warunkach aplikacja korzysta z~gotowych zbiorów danych:
\begin{itemize}
  \item Punkty - pochodzące ze zbioru ,,Państwowy rejestr nazw geograficznych - miejscowości'', zbiór zawiera 256796 obiektów, dostępny jest pod adresem \\http://www.codgik.gov.pl/index.php/darmowe-dane/prng.html.
  \item Linie - dane uzyskano z~serwisu http://download.geofabrik.de/europe/poland.html pozwalającego pobrać drogi z~terenu Polski z~bazy danych OpenStreetMap. Zbiór obejmuje 2519660 obiektów.
  \item Wielokąty - obiekty pobrano z~Państwowego Rejestru Granic dostępnego pod adresem http://gis-support.pl/baza-wiedzy/dane-do-pobrania/, zbiór liczy 59978 obiektów.
\end{itemize}

Każda wersja aplikacji posiada taką samą bazę danych, której schemat znajduje się na rysunku \ref{fig:erd}. Jako bazę danych wykorzystano PostgreSQL z~rozszerzeniem PostGIS. Dane geograficznej w~warstwie aplikacji przetwarzano używając biblioteki RGeo.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/erd}
  \caption{Schemat ERD bazy danych}
  \label{fig:erd}
\end{figure}

\section{Implementacja}

\section{Prezentacja aplikacji}

Do prezentacji danych na mapie wykorzystano bibliotekę Leflet, ponieważ jest darmowa i~ma otwarte źródła. Mapa pochodzi z~serwisu OpenStreetMap. Widok gotowej aplikacji znajduje się na rysunku \ref{fig:app}.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{pictures/app}
  \caption{Widok gotowej aplikacji}
  \label{fig:app}
\end{figure}

\chapter{Badania}

\section{Plan badań}

Na podstawie dostępnej dokumentacji oraz zaimplementowanych aplikacji w~każdym z~badanych narzędzi, frameworki zostaną porównane w~następujących aspektach:
\begin{itemize}
  \item dostępne funkcjonalności,
  \item struktura utworzonego projektu,
  \item wydajność zaimplementowanej aplikacji.
\end{itemize}

\subsection{Środowisko badawcze}

Do przeprowadznia badań użyto dwóch komputerów:

\begin{enumerate}
\item Komputer - serwer
  \begin{itemize}
    \item MacBook Pro (Retina, 13 cali, model: Early 2015)
    \item Procesor: Intel Core i5 2,7 GHz 2 rdzenie
    \item Pamięć RAM: 8GB DDR3 1867 MHz
    \item Dysk: 120GB APPLE SSD SM0128G
  \end{itemize}
\item Komputer - tester
  \begin{itemize}
    \item MacBook Mini 6.1
    \item Procesor: Intel Core i5 2,5 GHz 2 rdzenie
    \item Pamięć RAM: 8GB DDR3 1600 MHz
    \item Dysk: 240GB GOODRAM SSD CX100
  \end{itemize}
\end{enumerate}

Na \textit{komputerze - serwer} uruchomiona była aktualnie testowana aplikacja. \textit{Komputer - tester} wykonywał zaimplementowane badania. Podczas badań komputery były podłączone ze sobą lokalnie przy pomocy sieci Wi-Fi 802.11n i~nie miały dostępu do zewnętrznej sieci. Na komputerach uruchomione były tylko niezbędne aplikacje do przeprowadzenia badań.

\subsection{Narzędzia wykorzystane podczas badań}
Do zmierzenia wydajności zaimplementowanych aplikacji zastosowano następujące narzędzia:
\begin{itemize}
  \item{Capybara} - biblioteka w~języku Ruby pozwalająca symulować interakcje prawdziwego użytkownika z~wybraną aplikacją internetową. Capybara dostarcza szereg metod pozwalających zapisać jako scenariusz kolejne kroki postępowania użytkownika m.in. kliknięcie wybranego elementu lub wprowadzenie danych do formularza. Do wspierania JavaScriptu, Capybara używa Selenium. Selenium jest narzędziem, które umożliwia automatyczne wykonanie testów akceptacyjnych aplikacji internetowej w~wybranej przeglądarce. W przeprowadzonych badaniach testy uruchomione zostały w~przeglądarce Firefox. \cite{doc_capybara}
  \item{JMeter} - aplikacja napisana w~języku Java dostępna na licencji otwartego źródła. JMeter służy do wykonywania testów wydajności aplikacji internetowych. W niniejszych badaniach JMeter wykorzystywał protokół HTTP do wysyłania określonych zapytań do aplikacji. W badaniach pomocna również okazała się funkcja symulowania wielu użytkowników - JMeter uruchamia wybrany scenariusz na wielu wątkach aby sprawdzić jak zachowa się aplikacja przy wielu równoległych zapytaniach. \cite{doc_jmeter}
  \item{Ruby Benchmark} - biblioteka pozwalająca na zmierzenie czasu wykonywania podanego blogu kodu. Ruby Benchmark został wykorzystany przy zmierzeniu czasu wykonywania scenariuszy utworzonych przy pomocy Capybary oraz czasu wykonywania operacji na bazie danych. \cite{doc_benchmark}
\end{itemize}

\section{Porównanie funkcjonalności wybranych frameworków}

\subsection{Przechowywanie danych}

 Ruby on Rails posiada największe wsparcie w~przechowywaniu danych geograficznych z~rozpatrywanych narzędzi. Biblioteka ActiveRecord domyślne wykorzystywana w~Ruby on Rails do mapowania obiektowo-relacyjnego posiada adaptery dla następujących baz danych: PostgreSQL z~dodatkiem PostGIS, MysqlSpatial, SpatiaLite. Za pomocą adapterów, w~migracjach można używać typów kolumn z~przestrzennych baz danych. Przy komunikacji typy przestrzenne z~bazy danych mapowane są na typy zaimplementowane w~bibliotece RGeo. Konfiguracja nie wymaga wiele pracy, wystarczy dodać odpowiednią bibliotekę do projektu i~w konfiguracji bazy danych ustawić odpowiedni adapter. Od tego momentu można w~migracjach przy definiowaniu kolumn używać wszystkich typów przestrzennych dostarczanych przez wybraną bazę danych. Dane przestrzenne podczas wykonywanych akcji między aplikacją, a~bazą danych są automatycznie mapowane.

 Tworzenie bazy danych przestrzennej za pomocą Rody nie stanowi problemu. Framework pozwala używać kodu SQL w~migracjach dlatego można włączyć dowolne rozszerzenie wybranej bazy danych i~używać dodatkowych typów. Roda nie zapewnia specjalnego wsparcia przy mapowaniu danych przestrzennych na obiekty, dane są zwracane w~formie tekstowej binarnej wartości pola.

 Hanami w~migracjach pozwala ozywać kodu napisanego w~języku SQL do np. definiowania typów lub włączania dodatków w~bazie danych, dlatego bez problemów można stworzyć i~wersjonować bazę danych z~typami przestrzennymi. Jednak framework, podobnie jak Ruby on Rails, posiada mechanizm automatycznego mapowania typów bazy danych do typów obiektów, który nie pozwala na definiowanie własnych typów lub własnych reguł mapowania. To ograniczenie powoduje otrzymanie wyjątku przy próbie uruchomienia aplikacji zawierającej nieznany typ. Framework wspiera jedynie typy przestrzenne zdefiniowane w~bazie danych PostgreSQL, które są zapisywane postaci tekstowej zawierającej współrzędne. Możliwe jest zapisanie wszystkich 3 podstawowych typów przestrzennych: punktu, linii, wielokąta. PostgreSQL dostarcza podstawowe operacje wyszukiwania danych przestrzennych tylko dla punktów, dlatego zastosowanie PostgreSQL bez dodatku PostGIS mocno ogranicza możliwości budowanej aplikacji. Dodanie obsługi typów geometrycznych dostarczonych przez dodatek PostGIS nie wymaga dużej ilości kodu, wymagana jest dobra znajomość języka Ruby i~mechanizmu przedefiniowania istniejących już klas tzw. \textit{,,monkey patching''}. Najłatwiejsze rozwiązanie pozwalające używać typów geometrycznych z~biblioteki PostGIS znajduje się na listingu \ref{lst:postgis_patching}. Przy takim rozwiązaniu wartości z~kolumny geometrycznej mapowane są na typ String z~wartością binarną.

 \newpage

\begin{lstlisting}[language=Ruby, caption={Obsługa typów geometrycznych z~biblioteki PostGIS przez Hanami}, label=lst:postgis_patching]
require 'rom/sql/extensions/postgres/inferrer'
require 'rom/sql/extensions/postgres/types'

ROM::SQL::Schema::PostgresInferrer.class_eval do
  alias map_db_type_original map_db_type

  def map_db_type(db_type)
    # najpierw następuje próba użycia oryginalnej metody mapowania typów
    # jeśli zakończy się ona nie powodzeniem, to następuje sprawdzenie 
    # czy typ kolumny z~bazy danych rozpoczyna się od słowa 'geometry'
    # wtedy dane są rzutowane do typu ROM::Types::String
    map_db_type_original(db_type) || (db_type.start_with?('geometry') ? ROM::Types::String : nil)
  end
end
\end{lstlisting}

\subsection{Obiektowe przetwarzanie danych}

 Do obiektowego przetwarzania danych dostępne są dwie biblioteki RGeo i~GeoRuby. Ruby on Rails, dzięki wspomnianym wcześniej adapterom, dużo wygodniej jest korzystać z~RGeo dzięki automatycznemu mapowaniu danych relacyjnych na obiekty.
 Frameworki Roda oraz Hanami w~żaden sposób nie rozszerzają możliwości bibliotek RGeo i~GeoRuby. W  Hanami, zaimplementowana metoda mapująca wartości przestrzenne na typ obiektowy zwraca wartość binarną, Roda domyślne zwraca dane przestrzenne w~takiej formie. Wartość binarną dalej można zamienić na typ z~biblioteki RGeo, co zaprezentowano na listingu \ref{lst:coordinates_helper}

 \begin{lstlisting}[language=Ruby, caption={Tworzenie obiektu RGeo z~zapisu binarnego danych przestrzennych}, label=lst:coordinates_helper]
module CoordinatesHelper
  FACTORY = RGeo::Geographic.spherical_factory(:srid => 4326)

  # utworzenie obiektu RGeo z~binarnego zapisu danych przestrzennych
  def coordinates_object
    RGeo::WKRep::WKBParser.new(FACTORY, support_ewkb: true,
        default_srid: 4326).parse(coordinates)
  end

  # rzutowanie obiektu przestrzennego do postaci "well known text"
  def coordinates_text
    coordinates_object.as_text
  end
end
\end{lstlisting}

\subsection{Prezentowanie danych}

Framework Ruby on Rails posiada biblioteki do integracji obu narzędzi do prezentacji danych geograficznych wspomnianych w~rozdziale \ref{sec:maps-tools}:
\begin{enumerate}
  \item{Leaflet-rails} - dołącza do projektu Ruby on Rails bibliotekę Leaflet napisaną w~języku JavaScript wraz ze stylami CSS oraz dodaje metody do widoków pozwalające na dołączenie mapy i~podstawową konfiguracje bez potrzeby używania JavaScriptu.
  \item{Google Maps for Rails} - biblioteka opakowuje JavaScriptową bibliotekę GoogleMaps JavaScript API, ułatwiając jej dodanie do projektu.
\end{enumerate}
Dzięki takiej integracji zgodnie z~sposobem dołączania bibliotek do projektu w~języku Ruby \cite{doc_ruby}, wspomniane biblioteki są przechowywane centralnie w~systemie zamiast w~projekcie.
Roda oraz Hanami w~przeciwieństwie do Ruby on Rails nie posiadają bibliotek wspomagających dołączenie do projektu biblioteki Leaflet lub Google Maps JavaScript API. Żeby skorzystać jednej z~wymienionych bibliotek należy dołączyć jej kod do projektu.

Przy odczycie danych w~formacie JSON, Ruby on Rails oraz Roda automatycznie serializują model do postaci JSON. W projekcie wykorzystującym Hanami, niezbędne jest dodanie zewnętrznej bilbioteki realizującej serializowanie danych np. \textit{Roar} i~zdefiniowanie odpowiedniego prezentera. Przykładowy prezenter został zaprezentowany na listingu \ref{lst:representer}

 \begin{lstlisting}[language=Ruby, caption={Prezenter dla modelu Point}, label=lst:representer]
require 'roar/decorator'
require 'roar/json'

module Web::Representers
  class Point < Roar::Decorator
    include Roar::JSON

    property :id
    property :name
    property :object_type
    property :object_class
    property :voivodeship
    property :county
    property :commune
    property :terc
    property :coordinates_text
    property :color
  end
end
\end{lstlisting}

\subsection{Podsumowanie}

Ruby on Rails posiada zdecydowanie najwięcej gotowych narzędzi do pracy z~danymi geograficznymi z~rozpatrywanych frameworków. Tworzenie aplikacji dzięki temu trwa mniej czasu. Roda mimo mniejszego wsparcia dla danych przestrzennych w~przeciwieństwie do Hanami pozwala na ich używanie bez rozszerzania funkcjonalności frameworka. Hanami pozwala zbudować prosty system GIS wykorzystujący podstawowe typy przestrzenne dostępne w~bazie danych PostgreSQL, ale implementacja systemu informacji geograficznej wykorzystującego inną bazę danych za pomocą frameworku Hanami wymaga od programisty znacznie więcej pracy i~większych umiejętności programistycznych aby rozszerzyć możliwości frameworka.

\newpage

\section{Porównianie struktur wykonanych projektów}

Struktura zaimplementowanego projektu przy pomocy Ruby on Rails bezpośrednio odzwierciedla architekturę frameworku. W projekcie mamy jasny podział na Model-Widok-Kontroler. 

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [rails\_project
        [app
          [assets
            [javascripts
              [application.js 17, file]
              [checkboxes.js 72, file]
              [line\_form.js 33, file]
              [lines.js 38, file]
              [point\_form.js 33, file]
              [points.js 65, file]
              [polygon\_form.js 33, file]
              [polygons.js 36, file]
              [map.js 41, file]
            ]
            [stylesheets
              [application.scss 54, file]
            ]
          ]
          [controllers
            [application\_controller.rb 3, file]
            [lines\_controller.rb 50, file]
            [maps\_controller.rb 7, file]
            [points\_controller.rb 56, file]
            [polygons\_controller.rb 50, file]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [models
          [concerns
            [gis\_support.rb 15, file]
          ]
          [application\_record.rb 3, file]
          [line.rb 23, file]
          [point.rb 32, file]
          [polygon.rb 18, file]
        ]
        [views
          [layouts
            [application.html.erb 12, file]
          ]
          [maps
            [index.html.erb 91, file]
          ]
          [shared
            [\_line\_form.erb 11, file]
            [\_point\_form.html.erb 16, file]
            [\_polygon\_form.html.erb 13, file]
          ]
        ]
      ]
    \end{forest}
  \end{minipage}
  
    
  \caption{Struktura projektu Ruby on Rails}
  \label{fig:rails_proj_structure}
\end{figure}

\newpage
Filozofia prostoty w~frameworku Roda ma swoje odzwierciedlenie w~strukturze projektu, która nie posiada za wiele rozgałęzień.

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [roda\_project
        [assets
          [js
            [application.js 17, file]
            [checkboxes.js 63, file]
            [leaflet.js 5, file]
            [line\_form.js 58, file]
            [lines.js 39, file]
            [point\_form.js 59, file]
            [points.js 66, file]
            [polygon\_form.js 60, file]
            [polygons.js 37, file]
            [map.js 41, file]
          ]
          [css
            [leaflet.css 548, file]
            [main.css.scss 34, file]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [models
          [concerns
            [gis\_support.rb 16, file]
          ]
          [line.rb 20, file]
          [point.rb 23, file]
          [polygon.rb 19, file]
        ]
        [routes
          [lines.rb 47, file]
          [points.rb 47, file]
          [polygons.rb 47, file]
        ]
        [views
          [shared
            [\_line\_form.erb 12, file]
            [\_point\_form.erb 17, file]
          ]
          [index.erb 92, file]
          [layout.erb 14, file]
        ]
        [app.rb 33, file]
        [models.rb 24, file]
      ]
    \end{forest}
  \end{minipage}  
  \caption{Struktura projektu Roda}
  \label{fig:roda_proj_structure}
\end{figure}

Dodatkowe warstwy abstrakcji w~architekturze projektu Hanami przekładają się na bardziej rozbudowaną strukturę projektu.

\begin{figure}[H]
  \centering
  \begin{minipage}[H]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [hanami\_project
        [apps
          [web
            [assets
              [javascripts
                [application.js 17, file]
                [checkboxes.js 63, file]
                [leaflet.js 5, file]
                [line\_form.js 58, file]
                [lines.js 39, file]
                [point\_form.js 59, file]
                [points.js 66, file]
                [polygon\_form.js 60, file]
                [polygons.js 37, file]
                [map.js 41, file]
              ]
              [stylesheets
                [leaflet.css 548, file]
                [main.css.scss 34, file]
              ]
            ]
            [templates
              [map
                [index.html.erb 86, file]
              ]
              [shared
                [\_line\_form.html.erb 22, file]
                [\_point\_form.html.erb 42, file]
                [\_polygon\_form.html.erb 26, file]
              ]
              [application.html.erb 30, file]
            ]
          ]
        ]
      [...]]
    \end{forest}
  \end{minipage}
  \hfill
  \begin{minipage}[t!]{0.4\textwidth}
    \begin{forest}
      pic dir tree,
      where level=0{}{% folder icons by default; override using file for file icons
        directory,
      },
      [...
        [controllers
          [lines
            [create.rb 31, file]
            [destroy.rb 9, file]
            [index.rb 23, file]
            [update.rb 30, file]
          ]
          [points
            [create.rb 37, file]
            [destroy.rb 9, file]
            [index.rb 24, file]
            [update.rb 36, file]
          ]
          [polygons
            [create.rb 32, file]
            [destroy.rb 9, file]
            [index.rb 23, file]
            [update.rb 32, file]
          ]
          [map
            [index.rb 7, file]
          ]
        ]
        [representers
          [line.rb 12, file]
          [point.rb 17, file]
          [polygon.rb 13, file]
        ]
        [views
          [map
            [index.rb 26, file]
          ]
          [application\_layout.rb 7, file]
        ]
        [application.rb 65, file]
      ]
    \end{forest}
  \end{minipage}
  
    
  \caption{Struktura projektu Hanami - część I}
  \label{fig:hanami_1_proj_structure}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{forest}
    pic dir tree,
    where level=0{}{% folder icons by default; override using file for file icons
      directory,
    },
    [hanami\_project
      [lib
        [web
          [entities
            [line.rb 16, file]
            [point.rb 19, file]
            [polygon.rb 15, file]
          ]
          [repositories
            [concerns
              [coordinates\_helper.rb 10, file]
              [gis\_support.rb 16, file]
            ]
            [line\_repository.rb 7, file]
            [point\_repository.rb 7, file]
            [polygon\_repository.rb 7, file]
          ]
        ]
        [postgres\_inferrer.rb 8, file]
      ]
    ]
  \end{forest}   
  \caption{Struktura projektu Hanami - część II}
  \label{fig:hanami_2_proj_structure}
\end{figure}

Na rysunkach \ref{fig:files_count} i~\ref{fig:folders_count} można zauważyć, że projekt stworzony przy pomocy Hanami zawiera znacznie więcej plików i~folderów od dwóch pozostałych projektów. Dodatkowe warstwy abstrakcji w~architekturze frameworka przekładają się na bardziej skomplikowaną strukturę projektu. Projekty zrealizowany przy pomocy Ruby on Rails i~Roda zawierają dokładnie tyle samo plików, ale Roda ma nieco mniej folderów. Na rysunku \ref{fig:roda_proj_structure} można zauważyć, że struktura projektu Roda jest bardziej płaska niż struktura Ruby on Rails zaprezentowana na rysunku \ref{fig:rails_proj_structure}.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=50pt,
      enlarge x limits=0.15,
      ymin=0,
      xtick=\empty,
      legend cell align=left, legend pos=outer north east,
      ylabel={Liczba plików},
      nodes near coords,
      nodes near coords align={vertical}]
      \addplot coordinates {(1,45)};
      \addplot coordinates {(1,25)};
      \addplot[color=mygreen, fill=lightgreen] coordinates {(1,25)};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Liczba plików w~projekcie w~zależności od użytego frameworku}
  \label{fig:files_count}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=50pt,
      enlarge x limits=0.15,
      ymin=0,
      xtick=\empty,
      legend cell align=left, legend pos=outer north east,
      ylabel={Liczba folderów},
      nodes near coords,
      nodes near coords align={vertical}]
      \addplot coordinates {(1,21)};
      \addplot coordinates {(1,11)};
      \addplot[color=mygreen, fill=lightgreen] coordinates {(1,8)};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Liczba folderów w~projekcie w~zależności od użytego frameworku}
  \label{fig:folders_count}
\end{figure}

Na poniższym wykresie można zauważyć, że projekt Ruby on Rails zawiera najmniej linii kodu. Framework posiada wiele gotowych, wbudowanych funkcjonalności co ułatwia pracę programiście. Projekt Hanami zawiera najwięcej linii kodu co spowodowane jest skomplikowaną architekturą aplikacji, każda kolejna warstwa abstrakcji narzuca na programistę obowiązek napisania dodatkowego kodu realizującego komunikacje między warstwami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=50pt,
      enlarge x limits=0.15,
      ymin=0,
      xtick=\empty,
      legend cell align=left, legend pos=outer north east,
      ylabel={Liczba linii kodu},
      nodes near coords,
      nodes near coords align={vertical}]
      \addplot coordinates {(1,1780)};
      \addplot coordinates {(1,822)};
      \addplot[color=mygreen, fill=lightgreen] coordinates {(1,1438)};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Liczba linii kodu w~projekcie w~zależności od użytego frameworku}
  \label{fig:code_lines_count}
\end{figure}

\newpage
\section{Porównianie  wydajności zaimplemetowanych aplikacji}

Wszystkie wyniki badań wydajnościowych zostały uśrednione po 30 przebiegach.

\subsection{Interfejs użytkownika}

Badania na poziomie interfejsu użytkownika wykonano za pomocą Capybary, Selenium i~Ruby Benchmark. Każdy scenariusz obejmował kroki, które użytkownik musi wykonać w~aplikacji aby wykonać daną akcje. Badanie danego scenariusza, kończono w~chwili pojawienia się efektów wykonanej akcji w~interfejsie graficznym.

\subsubsection{Punkty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      legend cell align=left,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_point_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_point_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_point_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_point_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla punktu}
  \label{fig:crud_points}
\end{figure}

Framework Hanami okazał się najwolniejszy przy pojedynczych operacjach na obiektach typu punkt. Roda jest bardziej wydajna w~akcjach dodawania i~aktualizowania punktów, natomiast Ruby on Rails ma przewagę przy wyświetlaniu i~usuwaniu punktu.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba punktów na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_points_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_points_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_points_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w~zależności od liczby punktów}
  \label{fig:read_points}
\end{figure}

Na powyższym wykresie można zauważyć, że przewaga Rody i~Ruby on Rails nad Hanami jest stała i~nie zależy od liczby punktów.

\subsubsection{Linie}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_line_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_line_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_line_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_line_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:crud_lines}
\end{figure}

W operacjach na liniach można zauważyć, że Roda nie radzi sobie już tak dobrze jak z~obiektami punktowymi. Najlepiej wypada Ruby on Rails, dwa pozostałe frameworki uzyskały porównywalne wyniki.

\subsubsection{Wielokąty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_lines_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_lines_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_lines_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w~zależności od liczby linii}
  \label{fig:read_lines}
\end{figure}

Przy ładowaniu widoku zawierającego mniej niż 200 linii Roda i~Ruby on Rails dają podobne rezultaty. Przy większej liczbie linii Ruby on Rails zyskuje przewagę. Hanami wypada najgorzej, ale różnica między nim, a~dwoma pozostałymi frameworkami spada wraz ze wzrostem liczby linii.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_polygon_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [s]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/rails_cud_polygon_capybara_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/hanami_cud_polygon_capybara_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/roda_cud_polygon_capybara_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:crud_polygons}
\end{figure}

Podczas operacji na wielokątach Roda i~Hanami wypadły porównywalnie, obydwa frameworki dały gorsze rezultaty niż Ruby on Rails.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba wielokątów na mapie},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/rails_read_polygons_capybara_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/hanami_read_polygons_capybara_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/roda_read_polygons_capybara_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania widoku w~zależności od liczby wielokątów}
  \label{fig:read_polygons}
\end{figure}

Podczas ładowania większej liczby wielokątów, najszybciej zwiększał się czas wykonania akcji dla frameworku Hanami. Drugie miejsce zajęła Roda, najlepsze wyniki zarejestrowano z~użyciem Ruby on Rails.

\newpage

\subsection{Zapytania HTTP}

Wszystkie badania w~tym rozdziale wykonano przy pomocy aplikacji JMeter.

\subsubsection{Punkty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/rails_cud_point_capybara_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_point_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_point_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_point_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania zapytania HTTP dla punktu}
  \label{fig:http_crud_points}
\end{figure}

Czas pojedynczych operacji HTTP dla obiektów punktowych jednoznacznie pokazuje, że najbardziej wydajna jest aplikacja napisana z~użyciem Ruby on Rails, następnie Roda, a~najmniej wydajny okazał się framework Hanami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba punktów},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_points_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_points_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_points_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby punktów}
  \label{fig:http_read_points}
\end{figure}

Hanami bez względu na liczbę punktów wypada gorzej od dwóch pozostałych frameworków. Jeśli punktów jest mniej niż 40, Ruby on Rails wczytuje dane nieco szybciej niż Roda. Powyżej 70 punktów, lepsze wyniki uzyskano dla frameworku Roda.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_point_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_point_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_point_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby użytkowników}
  \label{fig:load_avg_time_point}
\end{figure}

Przy zwiększającej się liczbie użytkowników aplikacja wykorzystująca framework Hanami szybciej zwiększa swój czas odpowiedzi. Pozostałe dwie aplikacje zachowują się podobnie.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={liczba użytkowników},
      ylabel={liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_point_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_point_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_point_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{liczba obsłużonych zapytań na sekunde w~zależności od liczby użytkowników}
  \label{fig:load_rps_point}
\end{figure}

Początkowo Ruby on Rails obsługuje najwięcej użytkowników. Powyżej 200 użytkowników, Roda wyrównuje wynik frameworku Ruby on Rails - 169 użytkowników na sekundę.

\subsubsection{Linie}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/http/rails_crud_line_http_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_line_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_line_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_line_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:http_crud_lines}
\end{figure}

Tak samo jak dla punktów, najkrótszy czas operacji na liniach otrzymano w~badaniach aplikacji opartej na frameworku Ruby on Rails. Następne miejsce zajął framework Roda. Najdłuższy czas odpowiedzi otrzymano wykorzystując Hanami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_lines_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_lines_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_lines_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby linii}
  \label{fig:http_read_lines}
\end{figure}

Poniżej 500 linii na mapie wszystkie 3 aplikacje odpowiadały w~podobnym czasie. Przy większej liczby linii, czas odpowiedzi Hanami rósł szybciej niż pozostałych dwóch frameworków. Najkrótszy czas odpowiedzi dla danych liczących ponad 1000 linii zanotowano dla aplikacji wykorzystującej framework Roda.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [s]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_line_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_line_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_line_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby użytkowników}
  \label{fig:load_avg_time_line}
\end{figure}

Wraz ze wzrostem liczby użytkowników czas odpowiedzi aplikacji zbudowanej w~oparciu o~framework Hanami, rósł szybciej niż pozostałych dwóch aplikacji.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_line_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_line_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_line_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Liczba obsłużonych zapytań na sekunde w~zależności od liczby użytkowników}
  \label{fig:load_rps_line}
\end{figure}

Powyżej 200 użytkowników jednocześnie korzystających z~aplikacji, Roda i~Ruby on Rails w~ciągu sekundy obsługiwały około 190 użytkowników na sekundę. Przy mniejszej liczbie użytkowników Ruby on Rails obsługiwał więcej użytkowników w~ciągu sekundy od Rody. Hanami w~ciągu całego badania prezentował się znacznie gorzej od dwóch pozostałych frameworków i~maksymalnie w~ciągu sekundy odpowiedział na zapytanie 115 użytkowników.

\subsubsection{Wielokąty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=12pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/http/rails_crud_polygon_http_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/http/rails_crud_polygon_http_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/hanami_crud_polygon_http_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/http/roda_crud_polygon_http_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:http_crud_polygons}
\end{figure}

W podstawowych operacjach na wielokątach najlepsze czasy uzyskał framework Ruby on Rails, które były średnio dwukrotnie lepsze od wyników najwolniejszego frameworku Hanami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/http/rails_read_polygons_http_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/http/hanami_read_polygons_http_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/http/roda_read_polygons_http_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby wielokątów}
  \label{fig:http_read_polygons}
\end{figure}

Czas odpowiedzi aplikacji zbudowanej w~oparciu o~Hanami znacznie szybciej rósł w~porównaniu do dwóch pozostałych aplikacji. Ruby on Rails i~Roda uzyskały zbliżone czasy z~małą, stałą przewagą na korzyść Ruby on Rails.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/load/rails_polygon_avg_time.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_polygon_avg_time.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_polygon_avg_time.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas ładowania danych w~zależności od liczby użytkowników}
  \label{fig:load_avg_time_polygon}
\end{figure}

Dla danych typu wielokąt, Hanami znacznie wolniej obsługiwał zapytania przy wzrastającej liczbie użytkowników w~porównaniu do pozostałych frameworków. Najlepiej z~rosnącą liczbą użytkownik radził sobie framework Ruby on Rails.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba użytkowników},
      ylabel={Liczba obsłużonych zapytań na sekunde}]
      \pgfplotstableread[col sep=comma]{results/load/rails_polygon_rps.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/load/hanami_polygon_rps.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/load/roda_polygon_rps.csv}\rodatable;

      \addplot table[x index={0}, y index={1}] {\hanamitable};
      \addplot table[x index={0}, y index={1}] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x index={0}, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Liczba obsłużonych zapytań na sekunde w~zależności od liczby użytkowników}
  \label{fig:load_rps_polygon}
\end{figure}

Hanami zdołał maksymalnie obsłużyć 7 użytkowników w~ciągu sekundy i~ta liczba nie zmieniała się przy rosnącej liczbie użytkowników. Ruby on Rails, podobnie jak dla innych typów danych przy mniejszej liczbie użytkowników, mniej niż 200, obsługiwał więcej użytkowników niż Roda, jednak od 200 użytkowników jednocześnie korzystających z~aplikacji, oba frameworki obsługiwały prawie 50 użytkowników w~ciągu jednej sekundy.

\subsection{Komunikacja z~bazą danych}

Badania wydajności komunikacji z~bazą danych zrealizowano w~warstwie modelu każdej z~aplikacji. Czas wykonywania metod dla wybranych modeli zmierzono przy pomocy biblioteki Ruby Benchmark.

\subsubsection{Punkty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=15pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_point_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      compat=1.8]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_point_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_point_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_point_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla punktu}
  \label{fig:model_crud_points}
\end{figure}

W pojedynczych operacjach w~warstwie modelu czasy operacji na punktach były do siebie zbliżone dla 3 badanych frameworków. Najszybciej zadane operacje wykonał framework Roda.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba punktów},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_points_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_points_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_points_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z~bazy w~zależności od liczby punktów}
  \label{fig:model_read_points}
\end{figure}

Przy rosnącej liczbie wczytywanych punktów Roda i~Ruby on Rails uzyskały podobne wyniki, które były znacznie lepsze od Hanami.

\subsubsection{Linie}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=15pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_line_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_line_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_line_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_line_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla linii}
  \label{fig:model_crud_lines}
\end{figure}

Wyniki dla danych liniowych są analogiczne jak dla punktów, Roda uzyskała najlepsze rezultaty, a~najgorsze wyniki uzyskano dla Hanami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba linii na mapie},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_lines_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_lines_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_lines_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z~bazy w~zależności od liczby linii}
  \label{fig:model_read_lines}
\end{figure}

Przy danych liniowych nadal czas odpowiedzi Hanami rósł znacznie szybciej od dwóch pozostałych frameworków. Można zauważyć, że różnica między Hanami, a~Ruby on Rails jest bardziej zauważalna niż dla punktów, z~korzyścią na stronę Ruby on Rails.

\subsubsection{Wielokąty}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ybar=15pt,
      enlarge x limits=0.15,
      ymin=0,
      flexible xticklabels from table={results/model/rails_crud_polygon_model_50.csv}{0}{header=false,col sep=comma},
      xticklabel style={right=10pt,rotate=45,anchor=east}, % To make sure the text labels are nicely aligned
      xtick=data,
      legend cell align=left, legend pos=outer north east,
      ylabel={Czas [ms]},
      nodes near coords,
      nodes near coords align={vertical},
      ]
      \pgfplotstableread[header=false,col sep=comma]{results/model/rails_crud_polygon_model_50.csv}\railstable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/hanami_crud_polygon_model_50.csv}\hanamitable;
      \pgfplotstableread[header=false,col sep=comma]{results/model/roda_crud_polygon_model_50.csv}\rodatable;

      \addplot table[x expr=\coordindex, y index={1}] {\hanamitable};
      \addplot table[x expr=\coordindex, y index={1}] {\railstable};
      \addplot[color=mygreen, fill=lightgreen] table[x expr=\coordindex, y index={1}] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wykonania operacji CRUD dla wielokątów}
  \label{fig:model_crud_polygons}
\end{figure}

Badania dla wielokątów dały analogiczne wyniki jak dla dwóch poprzednich typów danych - Roda wykonywała operacje szybciej niż pozostałe frameworki. Najdłuższy czas otrzymano dla frameworku Hanami.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      width = 0.8\linewidth,
      height = 0.5\linewidth,
      ymin=0,
      xmin=0,
      xticklabel style={right=10pt, below=5pt,rotate=30,anchor=east},
      xlabel style={below=10pt},
      legend cell align=left, legend pos=outer north east,
      xlabel={Liczba wielokątów na mapie},
      ylabel={Czas [ms]}]
      \pgfplotstableread[col sep=comma]{results/model/rails_read_polygons_model_50.csv}\railstable;
      \pgfplotstableread[col sep=comma]{results/model/hanami_read_polygons_model_50.csv}\hanamitable;
      \pgfplotstableread[col sep=comma]{results/model/roda_read_polygons_model_50.csv}\rodatable;

      \addplot table[x=count, y=time] {\hanamitable};
      \addplot table[x=count, y=time] {\railstable};
      \addplot[mark=triangle*, mark options={scale=1.5}, color=mygreen] table[x=count, y=time] {\rodatable};
      \legend{Hanami, Ruby on Rails, Roda}
    \end{axis}
  \end{tikzpicture}
  \caption{Czas wczytywania danych z~bazy w~zależności od liczby wielokątów}
  \label{fig:model_read_polygons}
\end{figure}

Podobnie jak dla pozostałych typów danych geograficznych, dla aplikacji wykorzystującej framework Hanami odnotowano znacznie gorsze wyniki dla rosnącej liczby wczytywanych wielokątów niż dla pozostałych dwóch aplikacji. Jednak dla wielokątów różnica między frameworkiem Roda, a~Ruby on Rails jest bardziej zauważalna.

\chapter{Podsumowanie i wnioski}

\section{Podsumowanie wykonanej pracy}

\section{Analiza wyników badań}

Badania wykazały, że przy wyborze frameworku internetowego języka Ruby do budowy systemu informacji geograficznej najgorszym wyborem jest framework Hanami. Jego jedynym atutem może być rozbudowana architektura, która ułatwia organizacje kodu źródłowego w~rozbudowanych projektach. Jednak w~prostszych projektach, wiele warstw abstrakcji wymaga od programistów napisania więcej kodu źródłowego niż w~innych frameworkach do zaimplementowania takich samych funkcjonalności. Hanami jest znacznie mniej wydajny w~każdej z~badanych płaszczyzn - interfejsu użytkownika, zapytań HTTP, komunikacji z~bazą danych. Dodatkowo aby użyć innej przestrzennej bazy danych niż PostgreSQL trzeba zaimplementować wsparcie dla nowych typów danych, co nie jest konieczne przy korzystaniu z~innych frameworków.

Pozostałe dwa frameworki Ruby on Rails i~Roda podobnie wypadły w~badaniach wydajnościowych. Roda w~operacjach CRUD w~warstwie modelu była szybsza dla wszystkich typów danych od frameworku Ruby on Rails, jednak przy wczytywaniu bardziej skomplikowanych typów - linii i~wielokątów - dla Ruby on Rails zarejestrowano niższe czasy przy dużej liczbie danych. Na poziomie zapytań HTTP oraz interfejsu użytkownika, aplikacja wykorzystująca Ruby on Rails była bardziej wydajna zarówno dla  operacji na pojedynczych obiektach geograficznych, jak i~dla wczytywania większej liczby obiektów. Ruby on Rails posiada więcej bibliotek służących do pracy na dannych geograficznych co ma przełożenie na mniejszą ilość napisanego kodu dzięki gotowym funkcją. Struktura projektu Ruby on Rails i~projektu Roda jest bardzo podobna, projekty zawierały tyle samo plików.

\section{Realizacja celu projektu}
Niniejsza praca udowodniła, że za pomocą frameworków internetowych języka Ruby z~powodzeniem można stworzyć system informacji geograficznej. Najlepszym wyborem do budowy systemu GIS okazał się najbardziej popularny framework Ruby on Rails. Duża popularność przekłada się na duże wsparcie, wiele dostępnych bibliotek i~narzędzi do pracy z~danymi przestrzennymi. Ruby on Rails wymagał najmniej kodu źródłowego do zaimplementowania zaprojektowanego systemu, który wykazywał się największą wydajnościom przy przetwarzaniu danych geograficznych.
  
\begin{thebibliography}{99}
  \addcontentsline{toc}{chapter}{Literatura}

  \bibitem{doc_capybara}
  \emph{Dokumentacja biblioteki Capybara}, dostępna pod adresem:\\ \url{https://github.com/teamcapybara/capybara}, aktualne na dzień 18.06.2017r.

  \bibitem{doc_georuby}
  \emph{Dokumentacja biblioteki GeoRuby}, dostępna pod adresem:\\ \url{https://github.com/nofxx/georuby}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_google}
  \emph{Dokumentacja biblioteki Google Maps JavaScript API}, dostępna pod adresem:\\ \url{https://developers.google.com/maps/documentation/javascript/}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_leaflet}
  \emph{Dokumentacja biblioteki Leaflet}, dostępna pod adresem:\\ \url{http://leafletjs.com/reference-1.0.3.html}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_rgeo}
  \emph{Dokumentacja biblioteki Rgeo}, dostępna pod adresem:\\ \url{https://github.com/rgeo/rgeo}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_benchmark}
  \emph{Dokumentacja biblioteki Ruby Benchmark}, dostępna pod adresem:\\ \url{https://ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html}, aktualne na dzień 18.06.2017r.

  \bibitem{doc_hanami}
  \emph{Dokumentacja Hanami}, dostępna pod adresem:\\ \url{http://hanamirb.org/guides/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_ruby}
  \emph{Dokumentacja języka Ruby}, dostępna pod adresem:\\ \url{https://www.ruby-lang.org/pl/documentation/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_jmeter}
  \emph{Dokumentacja JMeter}, dostępna pod adresem:\\ \url{http://jmeter.apache.org/index.html}, aktualne na dzień 18.06.2017r.

  \bibitem{doc_mango}
  \emph{Dokumentacja MangoMap}, dostępna pod adresem:\\ \url{http://help.mangomap.com/}, aktualne na dzień 22.04.2017r.

  \bibitem{doc_mysql}
  \emph{Dokumentacja MySQL}, dostępna pod adresem:\\ \url{https://dev.mysql.com/doc/refman/5.7/en/}, aktualne na dzień 15.06.2017r.

  \bibitem{doc_osm}
  \emph{Dokumentacja OpenStreetMap}, dostępna pod adresem:\\ \url{http://wiki.openstreetmap.org/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_postgresql}
  \emph{Dokumentacja PostgreSQL}, dostępna pod adresem:\\ \url{https://www.postgresql.org/docs/9.6/static/index.html}, aktualne na dzień 09.06.2017r.

  \bibitem{doc_postgis}
  \emph{Dokumentacja PostGIS}, dostępna pod adresem:\\ \url{http://postgis.net/documentation/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_rails}
  \emph{Dokumentacja Ruby on Rails}, dostępna pod adresem:\\ \url{http://guides.rubyonrails.org/}, aktualne na dzień 08.03.2017r.

  \bibitem{doc_roda}
  \emph{Dokumentacja Roda}, dostępna pod adresem:\\ \url{http://roda.jeremyevans.net/documentation.html}, aktualne na dzień 01.06.2017r.

  \bibitem{doc_spatialite}
  \emph{Dokumentacja SpatiaLite}, dostępna pod adresem:\\ \url{https://www.gaia-gis.it/fossil/libspatialite/index}, aktualne na dzień 09.06.2017r.

  \bibitem{principles_gis}
  Huisman Otto, By (de) Rolf A., \emph{Principles of Geographic Information Systems}, ITC, 2009

  \bibitem{clean_architecture}
  Martin Robert, \emph{The Clean Architecture}, dostępna pod adresem:\\ \url{https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html}, aktualne na dzień 20.04.2017r.

  \bibitem{rails_agile}
  Ruby Sam, Thomas Dave, Hansson Heinemeier David, \emph{Agile Web Development with Rails 5}, Pragmatic Programmers, 2016

  \bibitem{gis_introduction}
  Schmandt Michael, \emph{GIS Commons: An Introductory Textbook on Geographic Information Systems}, dostępne pod adresem:\\
  \url{http://giscommons.org/}, aktualne na dzień 07.04.2017r.

  \bibitem{framework}
  Smyrdek Przemysław, \emph{Czym jest framework i~po co go używać}, dostępne pod adresem:\\
  \url{http://poznajprogramowanie.pl/czym-jest-framework-i-po-co-go-uzywac/}, aktualne na dzień 20.04.2017r.
  
\end{thebibliography}

\appendix

\chapter{Opis zawartości płyty CD}
W głównym katalogu załączonej do pracy płyty CD znajdują się:
\begin{itemize}
  \item mgr\_rails - kod źródłowy projektu Ruby on Rails
  \item mgr\_roda - kod źródłowy projektu Roda
  \item mgr\_hanami - kod źródłowy projektu Hanami
  \item jmeter\_benchmarks - kod źródłowy testów wydajnościowych napisanych za pomocą aplikacji JMeter
  \item capybara\_benchmarks - kod źródłowy testów wydajnościowych napisanych za pomocą biblioteki Capybara
  \item praca\_dyplomowa.pdf - niniejszy dokument
  \item streszczenie.pdf - streszczenie niniejszego dokumentu
\end{itemize}

\end{document}